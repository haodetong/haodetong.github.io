<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java/spring/spring-7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/java/spring/spring-7/" class="article-date">
  <time datetime="2018-05-06T03:01:39.000Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/06/java/spring/spring-7/">第七章 Spring与AOP AspectJ基于注解的AOP实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="7-1-AspectJ-基于注解的AOP实现-前置通知"><a href="#7-1-AspectJ-基于注解的AOP实现-前置通知" class="headerlink" title="7.1 AspectJ 基于注解的AOP实现 - 前置通知"></a>7.1 AspectJ 基于注解的AOP实现 - 前置通知</h4><p>指定ISomeService的doFirst()接入点为切入点，并执行前置方法</p>
<p>主业务接口</p>
<pre><code>public interface ISomeService {
    void doFirst();
    String doSecond(String str);
    void doThird();
}
</code></pre><p>业务实现类</p>
<pre><code>public class SomeServiceImpl implements ISomeService {
    @Override
    public void doFirst() {
        System.out.println(&quot;执行doFirst()方法&quot;);
    }
    @Override
    public String doSecond(String str) {
        System.out.println(&quot;执行doSecond()方法&quot;);
        return str;
    }
    @Override
    public void doThird() {
        System.out.println(&quot;执行doThird()方法&quot;);
    }
}
</code></pre><p>切面</p>
<pre><code>@Aspect //表示当前类为切面
public class MyAspect {
    //设置前置方法及切入点
    @Before(&quot;execution(* *..ISomeService.doFirst(..))&quot;)
    public void myBefore(JoinPoint jp) {
        System.out.println(&quot;执行前置方法jp=&quot;+jp);
    }
}
</code></pre><p>配置文件</p>
<pre><code>&lt;!-- 注册切面 --&gt;
&lt;bean id=&quot;myAspect&quot; class=&quot;com.siyantu.annotation.MyAspect&quot;&gt;&lt;/bean&gt;

 &lt;!-- 注册实现类 --&gt;
&lt;bean id=&quot;someService&quot; class=&quot;com.siyantu.annotation.SomeServiceImpl&quot; /&gt;

&lt;!-- aspectj自动代理 --&gt;
&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
</code></pre><p>测试类</p>
<pre><code>public class MyTest {
    @Test
    public void test() {
        String resource = &quot;applicationContext.xml&quot;;
        ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
        ISomeService service = (ISomeService) ac.getBean(&quot;someService&quot;);
        service.doFirst();
        System.out.println(&quot;=============&quot;);
        service.doSecond(&quot;abcde&quot;);
        System.out.println(&quot;=============&quot;);
        service.doThird();
        System.out.println(&quot;=============&quot;);

    }

}
</code></pre><h4 id="7-2-AspectJ-基于注解的AOP实现-后置通知"><a href="#7-2-AspectJ-基于注解的AOP实现-后置通知" class="headerlink" title="7.2 AspectJ 基于注解的AOP实现 - 后置通知"></a>7.2 AspectJ 基于注解的AOP实现 - 后置通知</h4><pre><code>@Aspect //表示当前类为切面
public class MyAspect {

    ...

    //设置后置方法及切入点，可以获取目标方法结果，但是因为没有返回值，所以没法修改
    @AfterReturning(value=&quot;execution(* *..ISomeService.doSecond(..))&quot;,returning=&quot;result&quot;)
    public void myAfterReturning(String result) {
        System.out.println(&quot;执行后置方法 result=&quot;+result);
    }

}
</code></pre><p>执行结果：</p>
<pre><code>执行前置方法jp=execution(void com.siyantu.annotation.ISomeService.doFirst())
执行doFirst()方法
=============
执行doSecond()方法
执行后置方法 result=abcde
=============
执行doThird()方法
=============
</code></pre><h4 id="7-3-AspectJ-基于注解的AOP实现-环绕通知"><a href="#7-3-AspectJ-基于注解的AOP实现-环绕通知" class="headerlink" title="7.3 AspectJ 基于注解的AOP实现 - 环绕通知"></a>7.3 AspectJ 基于注解的AOP实现 - 环绕通知</h4><pre><code>@Aspect //表示当前类为切面
public class MyAspect {

    ...
    //设置环绕通知及切入点
    @Around(&quot;execution(* *..ISomeService.doSecond(..))&quot;)
    public Object myAround(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println(&quot;执行环绕通知方法，目标方法执行之前&quot;);
        //目标方法
        Object result = pjp.proceed();
        System.out.println(&quot;执行环绕通知方法，目标方法执行之后&quot;);
        if(result != null) {
            result = ((String)result).toUpperCase();
        }
        return result;
    }

}
</code></pre><p>执行结果：</p>
<pre><code>执行前置方法jp=execution(void com.siyantu.annotation.ISomeService.doFirst())
执行doFirst()方法
=============
执行环绕通知方法，目标方法执行之前
执行doSecond()方法
执行环绕通知方法，目标方法执行之后
执行后置方法 result=ABCDE
=============
执行doThird()方法
=============
</code></pre><h4 id="7-4-AspectJ-基于注解的AOP实现-异常通知"><a href="#7-4-AspectJ-基于注解的AOP实现-异常通知" class="headerlink" title="7.4 AspectJ 基于注解的AOP实现 - 异常通知"></a>7.4 AspectJ 基于注解的AOP实现 - 异常通知</h4><h5 id="异常分两类："><a href="#异常分两类：" class="headerlink" title="异常分两类："></a>异常分两类：</h5><p>1、运行时异常，不进行处理，也可以通过编译。</p>
<p>若一个类继承自RunTimeException，则该异常就是运行时异常。</p>
<p>2、编译时异常，受查异常，Checked Exception。不进行处理，将无法通过编译。</p>
<p>若一个类继承自Exception，则该类就是受查异常。</p>
<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p>主业务接口</p>
<pre><code>public interface ISomeService {
    void doThird(String username, String password) throws UserException;
}
</code></pre><p>业务实现类</p>
<pre><code>public class SomeServiceImpl implements ISomeService {
    @Override
    public void doThird(String username, String password) throws UserException {
        if(!&quot;beijing&quot;.equals(username)) {
            throw new UsernameException(&quot;用户名有误&quot;);
        }
        if(!&quot;111&quot;.equals(password)) {
            throw new PasswordException(&quot;密码有误&quot;);
        }
    }
}
</code></pre><p>切面</p>
<pre><code>@Aspect //表示当前类为切面
public class MyAspect {

    //当目标方法抛出与指定类型的异常具有is-a关系的异常时，执行该异常通知方法    
    @AfterThrowing(value=&quot;execution(* *..ISomeService.doThird(..))&quot;,throwing=&quot;ex&quot;)
    public void myAfterThrowing(UsernameException ex) {
        System.out.println(&quot;发生用户名异常:&quot;+ex.getMessage());
    }

    @AfterThrowing(value=&quot;execution(* *..ISomeService.doThird(..))&quot;,throwing=&quot;ex&quot;)
    public void myAfterThrowing(PasswordException ex) {
        System.out.println(&quot;发生密码异常:&quot;+ex.getMessage());
    }

    @AfterThrowing(value=&quot;execution(* *..ISomeService.doThird(..))&quot;,throwing=&quot;ex&quot;)
    public void myAfterThrowing(Exception ex) {
        System.out.println(&quot;发生其它异常:&quot;+ex.getMessage());
    }

}
</code></pre><p>自定义UserException</p>
<pre><code>public class UserException extends Exception {
    public UserException() {
        super();
    }
    public UserException(String message) {
        super(message);
    }
}
</code></pre><p>自定义UsernameException</p>
<pre><code>public class UsernameException extends UserException {
    public UsernameException() {
        super();
        // TODO Auto-generated constructor stub
    }
    public UsernameException(String message) {
        super(message);
        // TODO Auto-generated constructor stub
    }
}
</code></pre><p>测试类</p>
<pre><code>异常处理方式一：将异常继续向上抛出，抛给虚拟机

public class MyTest {
    @Test
    public void test() throws UserException {
        String resource = &quot;applicationContext.xml&quot;;
        ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
        ISomeService service = (ISomeService) ac.getBean(&quot;someService&quot;);

        service.doThird(&quot;beijing&quot;,&quot;1112&quot;);

    }

}

异常处理方式二：捕捉异常，自己处理

public class MyTest {
    @Test
    public void test() {
        String resource = &quot;applicationContext.xml&quot;;
        ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
        ISomeService service = (ISomeService) ac.getBean(&quot;someService&quot;);

        try {
            service.doThird(&quot;beijing&quot;,&quot;1112&quot;);
        } catch (UserException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

}
</code></pre><h4 id="7-5-AspectJ-基于注解的AOP实现-最终通知"><a href="#7-5-AspectJ-基于注解的AOP实现-最终通知" class="headerlink" title="7.5 AspectJ 基于注解的AOP实现 - 最终通知"></a>7.5 AspectJ 基于注解的AOP实现 - 最终通知</h4><p>切面</p>
<pre><code>@Aspect //表示当前类为切面
public class MyAspect {

    //最终通知
    @After(&quot;execution(* *..ISomeService.doThird(..))&quot;)
    public void myAfter() {
        System.out.println(&quot;执行最终通知&quot;);
    }

}
</code></pre><p>不管有没有异常，最终通知都会执行</p>
<h4 id="7-6-AspectJ-基于注解的AOP实现-定义切入点"><a href="#7-6-AspectJ-基于注解的AOP实现-定义切入点" class="headerlink" title="7.6 AspectJ 基于注解的AOP实现 - 定义切入点"></a>7.6 AspectJ 基于注解的AOP实现 - 定义切入点</h4><pre><code>@Aspect //表示当前类为切面
public class MyAspect {

    //最终通知，使用定义的切入点替代表达式
    @After(&quot;doThirdPointcut()&quot;)
    public void myAfter() {
        System.out.println(&quot;执行最终通知&quot;);
    }

    //定义切入点
    @Pointcut(&quot;execution(* *..ISomeService.doThird(..))&quot;)
    public void doThirdPointcut() {}

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/06/java/spring/spring-7/" data-id="cjh4911mw0066mtp3t0fhkr9k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-6/" class="article-date">
  <time datetime="2018-05-05T06:34:38.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-6/">第六章 Spring与AOP AspectJ对AOP的实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring与AspectJ都对AOP这种编程思想进行了实现，但AspectJ实现方式更为简捷方便，而且还支持注解式开发。所以Spring又将AspectJ对于AOP的实现引入到了自己的框架中。</p>
<h4 id="6-1-AspectJ的通知类型"><a href="#6-1-AspectJ的通知类型" class="headerlink" title="6.1 AspectJ的通知类型"></a>6.1 AspectJ的通知类型</h4><pre><code>（1）、前置通知

（2）、后置通知

（3）、环绕通知

（4）、异常通知

（5）、最终通知
</code></pre><h4 id="6-2-AspectJ的切入点表达式"><a href="#6-2-AspectJ的切入点表达式" class="headerlink" title="6.2 AspectJ的切入点表达式"></a>6.2 AspectJ的切入点表达式</h4><p>表达式原型：</p>
<p>execution(<br>    [modifiers-pattern] 访问权限类型<br>    ret-type-apttern 返回值类型<br>    [declaring-type-pattern] 全限定性类名<br>    name-pattern(param-pattern) 方法名（参数名）<br>    [throws-pattern] 抛出异常类型<br>)</p>
<p>其中，返回值类型与方法名（参数名）不能省略。</p>
<p>切入点表达式要匹配的对象就是目标方法的方法名。</p>
<ul>
<li><p><code>*</code> ：代表0到多个任意字符</p>
</li>
<li><p><code>..</code>：用在方法参数中，表示任意多个参数；用在包名中表示当前包及其子包路径</p>
</li>
<li><p><code>+</code>：用在类名中，表示当前类及其子类；用在接口中表示当前接口及其实现类</p>
</li>
</ul>
<p><code>execution(* *..service.*.*(..))</code></p>
<p>表示指定所有包下的service子包下所有类或接口中所有方法为切入点</p>
<h4 id="6-3-测试环境的搭建"><a href="#6-3-测试环境的搭建" class="headerlink" title="6.3 测试环境的搭建"></a>6.3 测试环境的搭建</h4><p>#####（1）、导入jar包</p>
<p>AOP的jar包，AOP联盟的jar包，AspectJ的jar包，spring与AspectJ的整合jar包。</p>
<p>#####（2）、引入AOP的约束</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-6/" data-id="cjh4911mq005zmtp3s7fxho62" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-5/" class="article-date">
  <time datetime="2018-05-05T06:21:51.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-5/">第五章 Spring与AOP 简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="5-1-AOP编程术语"><a href="#5-1-AOP编程术语" class="headerlink" title="5.1 AOP编程术语"></a>5.1 AOP编程术语</h4><h5 id="（1）、切面（Aspect）"><a href="#（1）、切面（Aspect）" class="headerlink" title="（1）、切面（Aspect）"></a>（1）、切面（Aspect）</h5><p>切面泛指交叉业务逻辑。常用的切面有通知与顾问。</p>
<p>实际上就是对主业务逻辑的一种增强。</p>
<h5 id="（2）、织入（Weaving）"><a href="#（2）、织入（Weaving）" class="headerlink" title="（2）、织入（Weaving）"></a>（2）、织入（Weaving）</h5><p>将切面代码插入到目标对象的过程。</p>
<h5 id="（3）、连接点（JoinPoint）"><a href="#（3）、连接点（JoinPoint）" class="headerlink" title="（3）、连接点（JoinPoint）"></a>（3）、连接点（JoinPoint）</h5><p>通常业务中接口中的方法均为连接点。</p>
<h5 id="（4）、切入点（Pointcut）"><a href="#（4）、切入点（Pointcut）" class="headerlink" title="（4）、切入点（Pointcut）"></a>（4）、切入点（Pointcut）</h5><p>指切面具体织入的那个连接点。</p>
<p>被标记为final的方法是不能作为连接点和切入点的。</p>
<h5 id="（5）、目标对象（Target）"><a href="#（5）、目标对象（Target）" class="headerlink" title="（5）、目标对象（Target）"></a>（5）、目标对象（Target）</h5><p>目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。</p>
<p>如StudentServiceImpl等。</p>
<h5 id="（6）、通知（Advice）"><a href="#（6）、通知（Advice）" class="headerlink" title="（6）、通知（Advice）"></a>（6）、通知（Advice）</h5><p>通知是切入的一种实现。通知无法指定切入点，所有方法都会执行。</p>
<p>切入点定义切入的位置，通知定义切入的时间。</p>
<h5 id="7-、顾问（advisor）"><a href="#7-、顾问（advisor）" class="headerlink" title="(7)、顾问（advisor）"></a>(7)、顾问（advisor）</h5><p>顾问是切入的另一种实现。</p>
<p>能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-5/" data-id="cjh4911mn005wmtp3v2ivy5v4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-4/" class="article-date">
  <time datetime="2018-05-05T03:00:10.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-4/">第四章 Spring与IOC 基于注解的DI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DI-annotation</p>
<p>对于注解DI，不再需要在spring配置文件中声明Bean实例。</p>
<h5 id="（1）、导入AOP的jar包。"><a href="#（1）、导入AOP的jar包。" class="headerlink" title="（1）、导入AOP的jar包。"></a>（1）、导入AOP的jar包。</h5><p>注解的后台实现用到了AOP编程。</p>
<p>####（2）、添加约束头</p>
<p>约束在spring-framework-reference\html\xsd-configuration.html文件中</p>
<h4 id="3-、组件扫描器"><a href="#3-、组件扫描器" class="headerlink" title="(3)、组件扫描器"></a>(3)、组件扫描器</h4><p>配置文件中添加</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bjpowernode.di03&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>Student.class</p>
<pre><code>@Component(&quot;myStudent&quot;)//组件，表示该类被容器所管理
public class Student {
    @Value(&quot;zhangsan&quot;)
    private String name;
    @Value(&quot;23&quot;)
    private int age;

    private School school;

    ...

}
</code></pre><h4 id="4-1-组件扫描器的base-package"><a href="#4-1-组件扫描器的base-package" class="headerlink" title="4.1 组件扫描器的base-package"></a>4.1 组件扫描器的base-package</h4><p>扫描com.bjpowernode这个包及其子包</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bjpowernode&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>扫描com.bjpowernode这个包的子包</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bjpowernode.*&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><h4 id="4-1-基于注解的DI-Component相关注解"><a href="#4-1-基于注解的DI-Component相关注解" class="headerlink" title="4.1 基于注解的DI - @Component相关注解"></a>4.1 基于注解的DI - @Component相关注解</h4><p>与@Component注解，功能相同但是意义不同的注解还有三个：</p>
<ul>
<li><p>@Repository: 注解在Dao实现类上</p>
</li>
<li><p>@Service: 注解在Service实现类上</p>
</li>
<li><p>@Controller: 注解在SpringMVC的处理器上</p>
</li>
</ul>
<h4 id="4-2-基于注解的DI-Scope"><a href="#4-2-基于注解的DI-Scope" class="headerlink" title="4.2 基于注解的DI - @Scope"></a>4.2 基于注解的DI - @Scope</h4><p>不指定的话，默认也是singleton</p>
<pre><code>@Scope(&quot;prototype&quot;)
@Component(&quot;myStudent&quot;)
public class Student {
    @Value(&quot;zhangsan&quot;)
    private String name;
    @Value(&quot;23&quot;)
    private int age;
</code></pre><h4 id="4-3-基于注解的DI-域属性的注入"><a href="#4-3-基于注解的DI-域属性的注入" class="headerlink" title="4.3 基于注解的DI - 域属性的注入"></a>4.3 基于注解的DI - 域属性的注入</h4><p>byName方式的注入，要求@Autowired与@Qualifier联合使用</p>
<pre><code>@Scope(&quot;prototype&quot;)
@Component(&quot;myStudent&quot;)
public class Student {
    @Value(&quot;zhangsan&quot;)
    private String name;
    @Value(&quot;23&quot;)
    private int age;
    @Autowired
    @Qualifier(&quot;mySchool&quot;)
    private School school;//域属性的注解注入
    ...
}
</code></pre><h4 id="4-3-基于注解的DI-域属性的注入-使用-Resource注解"><a href="#4-3-基于注解的DI-域属性的注入-使用-Resource注解" class="headerlink" title="4.3 基于注解的DI - 域属性的注入 - 使用@Resource注解"></a>4.3 基于注解的DI - 域属性的注入 - 使用@Resource注解</h4><p>@Resource //byType的方式注入</p>
<p>@Resource(name=”mySchool”) //byName方式的注解注入</p>
<pre><code>@Component(&quot;myStudent&quot;)    
public class Student {
    ...
    //@Resource //byType的方式注入
    @Resource(name=&quot;mySchool&quot;) //byName方式的注解注入
    private School school;//域属性的注解注入
    ...
}
</code></pre><h4 id="4-4-基于注解的DI-使用Spring的JUnit4测试"><a href="#4-4-基于注解的DI-使用Spring的JUnit4测试" class="headerlink" title="4.4 基于注解的DI - 使用Spring的JUnit4测试"></a>4.4 基于注解的DI - 使用Spring的JUnit4测试</h4><h5 id="（1）、导入jar包"><a href="#（1）、导入jar包" class="headerlink" title="（1）、导入jar包"></a>（1）、导入jar包</h5><p>spring与junit4的整合jar包：spring-test.4.1.RELEASE.jar</p>
<p>测试类</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
//指定配置文件
@ContextConfiguration(locations=&quot;classpath:com/bjpowernode/di03/applicationContext.xml&quot;)
public class MyTest {
    //注解注入student
    @Resource(name=&quot;myStudent&quot;)
    private Student student;
    @Test
    public void test01() {
        System.out.println(student.toString());
    }
}
</code></pre><h4 id="4-5-Spring与IOC-DI-XML的优先级要基于注解的DI"><a href="#4-5-Spring与IOC-DI-XML的优先级要基于注解的DI" class="headerlink" title="4.5 Spring与IOC DI-XML的优先级要基于注解的DI"></a>4.5 Spring与IOC DI-XML的优先级要基于注解的DI</h4><p>同时存在基于XML的DI和基于注解的DI，XML的优先级要高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-4/" data-id="cjh4911mk005smtp3h1ihz8uv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-3/" class="article-date">
  <time datetime="2018-05-05T00:53:03.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-3/">第三章 Spring与IOC 基于XML的DI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Bean实例在调用无参构造器创建了空值对象后，就要对Bean对象的属性进行初始化。初始化是由容器自动完成的，称为注入。常用方式分为设值注入和构造注入。</p>
<h4 id="3-1-基于xml-设值注入"><a href="#3-1-基于xml-设值注入" class="headerlink" title="3.1 基于xml-设值注入"></a>3.1 基于xml-设值注入</h4><p>通过set方法注入，基本数据类型用value，引用数据类型用ref。</p>
<p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;mySchool&quot; class=&quot;com.bjpowernode.di01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;school&quot; ref=&quot;mySchool&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>School.class</p>
<pre><code>public class School {
    private String name;
    public void setName(String name) {
        this.name = name;
    }

}
</code></pre><p>Student.class</p>
<pre><code>public class Student {

    private String name;
    private int age;
    private School school;

    public Student() {
        super();
    }

    public void setSchool(School school) {
        this.school = school;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, school=&quot; + school + &quot;]&quot;;
    }

}
</code></pre><h4 id="3-2-基于xml-为集合属性赋值"><a href="#3-2-基于xml-为集合属性赋值" class="headerlink" title="3.2 基于xml-为集合属性赋值"></a>3.2 基于xml-为集合属性赋值</h4><p>Some.class</p>
<pre><code>public class Some {
    private School[] schools;
    private String[] myStrs;
    private List&lt;String&gt; myList;
    private Set&lt;String&gt; mySet;
    private Map&lt;String,Object&gt; myMap;
    private Properties myPros;
    ...
    set 方法
    ...
    @Override
    public String toString() {
        return &quot;Some [schools=&quot; + Arrays.toString(schools) + &quot;, mystrs=&quot; + Arrays.toString(myStrs) + &quot;, myList=&quot;
                + myList + &quot;, mySet=&quot; + mySet + &quot;, myMap=&quot; + myMap + &quot;, myPros=&quot; + myPros + &quot;]&quot;;
    }
}
</code></pre><p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;mySchool1&quot; class=&quot;com.bjpowernode.di02.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;mySchool2&quot; class=&quot;com.bjpowernode.di02.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;北京大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;mySome&quot; class=&quot;com.bjpowernode.di02.Some&quot;&gt;
    &lt;property name=&quot;schools&quot;&gt;
        &lt;array&gt;
            &lt;ref bean=&quot;mySchool1&quot;/&gt;
            &lt;ref bean=&quot;mySchool2&quot;/&gt;
        &lt;/array&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myStrs&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;山东&lt;/value&gt;
            &lt;value&gt;临沂&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;平邑&lt;/value&gt;
            &lt;value&gt;一村&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;

    &lt;property name=&quot;mySet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;一街道&lt;/value&gt;
            &lt;value&gt;二街道&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;mobile&quot; value=&quot;15011111111&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;qq&quot; value=&quot;11111&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myPros&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;age&quot;&gt;12&lt;/prop&gt;
            &lt;prop key=&quot;sex&quot;&gt;femal&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-3-基于xml-域属性-自动注入"><a href="#3-3-基于xml-域属性-自动注入" class="headerlink" title="3.3 基于xml-域属性-自动注入"></a>3.3 基于xml-域属性-自动注入</h4><h5 id="3-3-1-基于xml-autowire-quot-byName-quot"><a href="#3-3-1-基于xml-autowire-quot-byName-quot" class="headerlink" title="3.3.1 基于xml-autowire=&quot;byName&quot;"></a>3.3.1 基于xml-<code>autowire=&quot;byName&quot;</code></h5><p>会从容器中查找与Student类中域属性名scholl相同的Bean的id，并将该Bean对象自动注入给该域属性</p>
<pre><code>&lt;bean id=&quot;school&quot; class=&quot;com.bjpowernode.di01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h5 id="3-3-2-基于xml-autowire-quot-byType-quot"><a href="#3-3-2-基于xml-autowire-quot-byType-quot" class="headerlink" title="3.3.2 基于xml-autowire=&quot;byType&quot;"></a>3.3.2 基于xml-<code>autowire=&quot;byType&quot;</code></h5><p>会从容器中查找与Student类中域属性类型School具有is-a关系的Bean，并将该Bean对象自动注入给该域属性</p>
<pre><code>&lt;bean id=&quot;mySchool&quot; class=&quot;com.bjpowernode.di01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h5 id="3-3-3-基于xml-DI-SPEL注入"><a href="#3-3-3-基于xml-DI-SPEL注入" class="headerlink" title="3.3.3 基于xml-DI-SPEL注入"></a>3.3.3 基于xml-DI-SPEL注入</h5><pre><code>&lt;bean id=&quot;myPerson&quot; class=&quot;com.bjpowernode.di01.Person&quot;&gt;
    &lt;property name=&quot;pname&quot; value=&quot;lisi&quot;&gt;&lt;/property&gt;
    &lt;!-- 通过spring el表达式调用静态方法 --&gt;
    &lt;property name=&quot;page&quot; value=&quot;#{T(java.lang.Math).random() * 50}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot;&gt;
    &lt;!-- 调用其它Bean的属性 --&gt;
    &lt;property name=&quot;name&quot; value=&quot;#{myPerson.pname}&quot;&gt;&lt;/property&gt;
    &lt;!-- 运算 --&gt;
    &lt;property name=&quot;age&quot; value=&quot;#{myPerson.page &gt; 25 ? 25 : myPerson.page}&quot;&gt;&lt;/property&gt;
    &lt;!-- 调用其它Bean的成员方法 --&gt;
    &lt;property name=&quot;age&quot; value=&quot;#{myPerson.computeAge()}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-4-为应用指定多个Spring配置文件"><a href="#3-4-为应用指定多个Spring配置文件" class="headerlink" title="3.4 为应用指定多个Spring配置文件"></a>3.4 为应用指定多个Spring配置文件</h4><h5 id="1-、平等关系的配置文件"><a href="#1-、平等关系的配置文件" class="headerlink" title="(1)、平等关系的配置文件"></a>(1)、平等关系的配置文件</h5><p>两个配置文件：</p>
<ul>
<li><p>com/bjpowernode/di01/spring-base.xml</p>
</li>
<li><p>com/bjpowernode/di01/spring-beans.xml</p>
</li>
</ul>
<p>创建容器：</p>
<pre><code>String source01 = &quot;com/bjpowernode/di01/spring-base.xml&quot;;
String source02 = &quot;com/bjpowernode/di01/spring-beans.xml&quot;;
ApplicationContext ac = new ClassPathXmlApplicationContext(source01,source02);
</code></pre><p>通配符</p>
<pre><code>String source = &quot;com/bjpowernode/di01/spring-*.xml&quot;;
ApplicationContext ac = new ClassPathXmlApplicationContext(source);
</code></pre><h5 id="2-、包含关系的配置文件"><a href="#2-、包含关系的配置文件" class="headerlink" title="(2)、包含关系的配置文件"></a>(2)、包含关系的配置文件</h5><p>三个配置文件：</p>
<ul>
<li><p>com/bjpowernode/di01/applicationContext.xml</p>
</li>
<li><p>com/bjpowernode/di01/spring-base.xml</p>
</li>
<li><p>com/bjpowernode/di01/spring-beans.xml</p>
</li>
</ul>
<p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
...
&gt;
   &lt;!--引入其它的配置文件--&gt;     
    &lt;import resource=&quot;classpath:com/bjpowernode/di01/spring-base.xml&quot; /&gt;
    &lt;import resource=&quot;classpath:com/bjpowernode/di01/spring-beans.xml&quot; /&gt;

    &lt;!--通配符--&gt;
    &lt;import resource=&quot;classpath:com/bjpowernode/di01/spring-*.xml&quot; /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-3/" data-id="cjh4911mf005mmtp39fmg11q7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/04/java/spring/spring-2/" class="article-date">
  <time datetime="2018-05-04T07:28:48.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/java/spring/spring-2/">第二章 spring与IOC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>控制反转（IOC,Inversion of control），是一个概念，是一种思想。指将传上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。</p>
<p>比较流行的两种实现方式有两种：</p>
<ul>
<li><p>依赖查找：Dependency Lookup, DL，容器提供回调接口与上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于JNDI服务接口（java naming and directory interrface）的查找。</p>
</li>
<li><p>依赖注入：Dependency Injection， DI，程序代码不做定位查找，这些工作由容器自行完成。</p>
</li>
</ul>
<p>依赖注入是目前最优秀的解耦方式。依赖注入让spring的Bean之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合到一起。</p>
<h4 id="2-1-创建spring容器"><a href="#2-1-创建spring容器" class="headerlink" title="2.1 创建spring容器"></a>2.1 创建spring容器</h4><pre><code>public class MyTest {
    @Test
    public void test01() {
        SomeServiceImpl service = new SomeServiceImpl();
        service.doSome();
    }

    @Test
    public void test02() {
        //从当前应用的类路径下查找
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        ISomeService service = (ISomeService) ac.getBean(&quot;myService&quot;);
        service.doSome();
    }

    @Test
    public void test03() {
        //从当前应用的根路径下查找
        ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;);
        ISomeService service = (ISomeService) ac.getBean(&quot;myService&quot;);
        service.doSome();
    }

    @Test
    public void test04() {
        BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));
        ISomeService service = (ISomeService) bf.getBean(&quot;myService&quot;);
        service.doSome();
    }

}
</code></pre><p>applicationContext与BeanFactory两种容器的区别：对于其中的Bean的创建时机不同。</p>
<ul>
<li><p>applicationContext容器在进行初始化时，会将其中的所有Bean对象进行创建。</p>
<p>缺点：占用系统资源（内存、cpu等）</p>
<p>优点：响应速度快</p>
</li>
<li><p>BeanFactory容器中的对象，在容器初始化时并不会创建，而是在真正调用时才会被创建</p>
<p>缺点： 响应速度慢</p>
<p>优点： 不多占用系统资源</p>
</li>
</ul>
<h4 id="2-2-Bean的装配"><a href="#2-2-Bean的装配" class="headerlink" title="2.2 Bean的装配"></a>2.2 Bean的装配</h4><p>Bean的装配，即Bean的创建。</p>
<p>底层应用反射机制，通过调用无参构造器创建的Bean对象。</p>
<h4 id="2-3-动态工厂Bean"><a href="#2-3-动态工厂Bean" class="headerlink" title="2.3 动态工厂Bean"></a>2.3 动态工厂Bean</h4><p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 注册动态工厂 --&gt;
    &lt;bean id=&quot;factory&quot; class=&quot;com.bjpowernode.service.ServiceFactory&quot; /&gt;

    &lt;!-- 注册Service:动态工厂Bean --&gt;
    &lt;bean id=&quot;myService&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getSomeService&quot; /&gt;

&lt;/beans&gt;
</code></pre><p>动态工厂</p>
<pre><code>public class ServiceFactory {
    public ISomeService getSomeService() {
        return new SomeServiceImpl();
    }
}
</code></pre><p>接口</p>
<pre><code>public interface ISomeService {
    void doSome();
}
</code></pre><p>实现类</p>
<pre><code>public class SomeServiceImpl implements ISomeService {

    @Override
    public void doSome() {
        System.out.println(&quot;execute dosome() method&quot;);
    }

}
</code></pre><p>测试类</p>
<p>public class MyTest {</p>
<pre><code>@Test
public void test05() {
    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;);
    ISomeService service = (ISomeService) ac.getBean(&quot;myService&quot;);
    service.doSome();
}
</code></pre><p>}</p>
<h4 id="2-4-静态工厂Bean"><a href="#2-4-静态工厂Bean" class="headerlink" title="2.4 静态工厂Bean"></a>2.4 静态工厂Bean</h4><p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 注册Service:静态工厂Bean --&gt;
    &lt;bean id=&quot;myService&quot; class=&quot;com.bjpowernode.service.ServiceFactory&quot; factory-method=&quot;getSomeService&quot; /&gt;

&lt;/beans&gt;
</code></pre><p>静态工厂</p>
<pre><code>public class ServiceFactory {
    public static ISomeService getSomeService() {
        return new SomeServiceImpl();
    }
}
</code></pre><h4 id="2-5-Bean的作用域"><a href="#2-5-Bean的作用域" class="headerlink" title="2.5 Bean的作用域"></a>2.5 Bean的作用域</h4><pre><code>&lt;bean id=&quot;myService&quot; class=&quot;com.bjpowernode.service.SomeServiceImpl&quot; scope=&quot;singleton&quot; /&gt;
</code></pre><p><code>scope=&quot;singleton&quot;</code> 单例模式：容器中对象的创建是在Spring容器初始化时就全部创建，是默认值</p>
<p><code>scope=&quot;prototype&quot;</code> 原型模式：容器中对象的创建时机不是在Spring容器初始化时创建，而是在代码中真正访问时才创建</p>
<pre><code>ISomeService service1 = (ISomeService) ac.getBean(&quot;myService&quot;);

ISomeService service2 = (ISomeService) ac.getBean(&quot;myService&quot;);
</code></pre><p>默认，即单例模式下，service1与service2从容器中获取的是同一个对象</p>
<p>原型模式下，service1与service2分别创建新的对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/04/java/spring/spring-2/" data-id="cjh4911mi005qmtp3caexrlhh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/04/java/spring/spring-1/" class="article-date">
  <time datetime="2018-05-04T06:33:18.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/java/spring/spring-1/">第一章 spring概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>spring的核心是控制反转（IOC）和面向切面编程（AOP）。</p>
<p>spring的主要作用就是为代码“解耦”，降低代码间的耦合度。</p>
<p>spring根据代码功能特点，将降低耦合度的方式分为了两类：IOC与AOP。<br>IOC使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建使用的对象了。而是由spring容器统一管理，自动“注入”。而AOP使得系统级服务得到了最大复用，且不用由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由spring容器统一完成“织入”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/04/java/spring/spring-1/" data-id="cjh4911ma005fmtp3nee1sve4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-session-cookie/session-cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/java/java-session-cookie/session-cookie/" class="article-date">
  <time datetime="2018-04-27T02:12:04.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/java/java-session-cookie/session-cookie/">session&amp;cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-1-cookie简介"><a href="#1-1-cookie简介" class="headerlink" title="1.1 cookie简介"></a>1.1 cookie简介</h4><p>cookie是1993年由网景公司前雇员发明的一种进行网络会话状态跟踪的技术。</p>
<p>会话是由一组请求与响应组成，是围绕着一种相关事情所进行的请求与响应。所以这些请求与响应之间一定是需要有数据传递的，即需要进行会话状态跟踪。然而HTTP协议是一种无状态协议，在不同的请求之间是无法进行数据传递的。此时就需要一种可以进行请求之间进行数据传递的会话跟踪技术，而cookie就是一种这样的技术。</p>
<p>cookie是由服务器生成，保存在客户端的一种信息载体。这个载体中存放着用记访问该站点的会话状态信息。只在cookie没有被清空，或者cookie没有失效，那么，保存在其中的会话状态就有效。</p>
<p>用户在提交第一次请求后，由服务器生成cookie，并将其封装到响应头中，以响应的形式发送给客户端。客户端接收到这个响应后，将cookie保存到客户端。当客户端再次发送同类请求后（资源路径相同，资源名称不同），在请求中会携带保存在客户端的cookie数据，发送到客户端，由服务器对会话进行跟踪。</p>
<p>cookie技术并不是jvavaweb开发的专属技术，而是属于web开发的技术，是所有web开发语言均支持的技术。</p>
<p>cookie是由若干键值对构成，键值对均为字符串。</p>
<h4 id="1-2-javaEE中的cookie"><a href="#1-2-javaEE中的cookie" class="headerlink" title="1.2 javaEE中的cookie"></a>1.2 javaEE中的cookie</h4><p>在javaEE中的javax.servlet.http包中存在一个类Cookie，就是用于完成会话跟踪的Cookie。其只有一个带参构造器。</p>
<h5 id="默认绑定路径"><a href="#默认绑定路径" class="headerlink" title="默认绑定路径"></a>默认绑定路径</h5><p>访问路径由资源路径与资源名称构成。默认情况下，cookie与访问路径中的资源路径绑定。只要用户发出带有绑定资源路径的请求，则在请求头部，将会自动携带与之绑定的cookie路径。</p>
<h5 id="生成cookie"><a href="#生成cookie" class="headerlink" title="生成cookie"></a>生成cookie</h5><pre><code>public class SomeServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());
        //创建两个Cookie
        Cookie cookie = new Cookie(&quot;company&quot;,&quot;abc&quot;);
        Cookie cookie2 = new Cookie(&quot;teacher&quot;,&quot;def&quot;);

        //指定cookie绑定的资源路径。必须加上项目名称
        cookie.setPath(request.getContextPath() + &quot;/aaa/bbb/ccc&quot;);
        cookie2.setPath(request.getContextPath() + &quot;/ddd/eee/fff&quot;);

        //设置cookie有效期
        //大于0，表示将cookie存放到客户端硬盘
        //小于0，与不设置一样，会将cookie存放到浏览器的缓存
        //等于0，表示cookie一生成，马上失效
        cookie.setMaxAge(60 * 60);
        cookie2.setMaxAge(60 * 60 * 24 * 10);

        //向响应中添加Cookie
        response.addCookie(cookie);
        response.addCookie(cookie2);

    }
}
</code></pre><h5 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h5><pre><code>public class OhterServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());

        Cookie[] cookies = request.getCookies();

        for(Cookie cookie:cookies) {
            System.out.println(cookie.getName() + &quot;===&quot; + cookie.getValue());
            if(cookie.getName().equals(&quot;teacher&quot;) &amp;&amp; cookie.getValue().equals(&quot;aaa&quot;)) {
                //...
            } else {
                //..
            }
        }
    }

}
</code></pre><h4 id="2-1-HttpSession"><a href="#2-1-HttpSession" class="headerlink" title="2.1 HttpSession"></a>2.1 HttpSession</h4><p> session，即会话，是web开发中的一种会话状态跟踪技术。不同的是,cookie是将会话状态保存在了客户端，而session是将会话状态保存在了服务器端。</p>
<p> 在javaweb开发中，session是以javax.servlet.HttpSession的接口对象的形式出现。</p>
<hr>
<p>对于request的getSession()的用法：</p>
<ul>
<li><p>一般情况下，若要向session域中写入数据，则需要使用getSession(true)，即getSession()方法。意味着有老的session用老的，没有老的则创建新的。</p>
</li>
<li><p>若要从session中读取数据，则需要使用getSession(false)。意味着有老的session用老的，没有老的返回null。</p>
</li>
</ul>
<hr>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action = &quot;FirstServlet&quot; method = &quot;POST&quot;&gt;
        用户名：&lt;input type = &quot;text&quot; name = &quot;username&quot; /&gt;
        &lt;input type = &quot;submit&quot; value = &quot;提交&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p> FirstServlet</p>
<pre><code>public class FirstServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取用户提交的数据
        String username = request.getParameter(&quot;username&quot;);

        //将参数放到request域
        request.setAttribute(&quot;user&quot;, username);

        //获取session对象
        HttpSession session = request.getSession();

        //向session域中写入数据
        session.setAttribute(&quot;username&quot;, username);

        response.getWriter().print(&quot;SomeServlet&quot; + username);

    }

}
</code></pre><p>SecondServlet</p>
<pre><code>public class SecondServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //从request域中读取user属性
        Object user = request.getAttribute(&quot;user&quot;);

        //获取session
        HttpSession session = request.getSession(false);

        //从session中读取指定属性
        String username = null;
        if(session != null) {
            username = (String) session.getAttribute(&quot;username&quot;);
        }

        PrintWriter out = response.getWriter();
        out.println(&quot;user = &quot; + user);
        out.println(&quot;username = &quot; + username);
        out.println(&quot;session = &quot; + session);
    }

}
</code></pre><h4 id="2-2-Session的工作原理"><a href="#2-2-Session的工作原理" class="headerlink" title="2.2 Session的工作原理"></a>2.2 Session的工作原理</h4><p>在服务器中系统会为每个会话维护一个Session。不同的会话，对应不同的Session。那么，系统是如何识别Session对象的？即是如何做到在同一个会话过程中，一直使用的是同一个Session对象呢？</p>
<h5 id="（1）、写入Session列表"><a href="#（1）、写入Session列表" class="headerlink" title="（1）、写入Session列表"></a>（1）、写入Session列表</h5><p>服务器对当前应用中的Session是以Map的形式进行管理的，这个Map称为Session列表。该Map的key为一个32位长度的随机串，这个随机串称为JSessionID，value则为Session对象的引用。</p>
<p>当用户每一次提交请求时，服务端Servlet中执行到request.getSession()方法后，会自动生成一个Map.entry对象，key为一个根据某种算法新生成的JSessionID，value则为新创建的HttpSession对象。</p>
<h5 id="2-、服务器生成并发送cookie"><a href="#2-、服务器生成并发送cookie" class="headerlink" title="(2)、服务器生成并发送cookie"></a>(2)、服务器生成并发送cookie</h5><p>在将session信息写入session列表后，系统还会自动将“JSessionID”作为name,这个32位长度的随机串作为value，以cookie的形式存放到响应报头中，并随着响应，将该cookie发送到客户端。</p>
<p><a href="http://localhost:8080/sessioncookie" target="_blank" rel="external">http://localhost:8080/sessioncookie</a><br>提交表单，跳转到FirstServlet后，</p>
<pre><code>Response Headers

Content-Length: 13

Date: Fri, 27 Apr 2018 07:54:40 GMT

Set-Cookie: JSESSIONID=DCCE10CC2F5A6FAE40B716CA91B01EB0; Path=/sessioncookie; HttpOnly
</code></pre><h5 id="3-、客户端接收并发送cookie"><a href="#3-、客户端接收并发送cookie" class="headerlink" title="(3)、客户端接收并发送cookie"></a>(3)、客户端接收并发送cookie</h5><p>客户端接收到这个cookie后会将其存放到浏览器缓存中。即，只要客户端浏览器不关闭，浏览器缓存中的cookie就不会消失。</p>
<p>当用户提交第二次请求时，会将缓存中的这个cookie，伴随着请求的头部信息，一块发送到服务端。</p>
<p>再次发送请求时，<a href="http://localhost:8080/sessioncookie/SecondServlet" target="_blank" rel="external">http://localhost:8080/sessioncookie/SecondServlet</a></p>
<pre><code>Request Headers

...

Cookie: JSESSIONID=DCCE10CC2F5A6FAE40B716CA91B01EB0

Host: localhost:8080
</code></pre><p>（4）、从session列表中查找</p>
<p>服务端从请求中读取到客户端发送来的cookie，并根据cookie的SeesionID的值，从Map中查找相应key所对应的value，即session对象。然后，该session的域属性进行读写操作。</p>
<h4 id="2-3-Session的失效"><a href="#2-3-Session的失效" class="headerlink" title="2.3 Session的失效"></a>2.3 Session的失效</h4><p>若某个session在指定的时间内一直未被访问，那么session将超时，即将失效。</p>
<p>在web.xml中可以通过<code>&lt;session-config /&gt;</code>标签设置session的超时时间，单位为分钟。默认的超时时间为30分钟。时间从最后一次访问开始计时。</p>
<pre><code>&lt;session-config&gt;
    &lt;session-timeout&gt;120&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p>若未到超时时间，也可以通过HttpSession中的方法invalide()，使得session失效。</p>
<h4 id="2-4-cookie禁用后的session"><a href="#2-4-cookie禁用后的session" class="headerlink" title="2.4 cookie禁用后的session"></a>2.4 cookie禁用后的session</h4><p>cookie禁用后，从someServlet跳转到otherServlet时，</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取用户提交的数据
        String username = request.getParameter(&quot;username&quot;);

        //获取session对象
        HttpSession session = request.getSession();

        //向session域中写入数据
        session.setAttribute(&quot;username&quot;, username);

        //跳转到otherServlet
        response.sendRedirect(request.getContextPath() + &quot;/otherServlet&quot;);    
    }
</code></pre><p>someServlet发送到客户端的包含有sessionid的cookie并没有被客户端保存，所以在发送otherServlet请求时，没有将该包含有sessionid的cookie发送到服务端，因此otherServlet服务端找不到该session，也就不能读取里面的数据。</p>
<h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>request.encodeRedirectURL()方法</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //获取用户提交的数据
    String username = request.getParameter(&quot;username&quot;);

    //获取session对象
    HttpSession session = request.getSession();

    //向session域中写入数据
    session.setAttribute(&quot;username&quot;, username);

    //跳转到otherServlet
    String uri = request.getContextPath() + &quot;/otherServlet&quot;;
    uri = request.encodeRedirectURL(uri);
    response.sendRedirect(uri);    
}
</code></pre><p>这样的话，跳转到otherServlet时，会将sessionid包含到访问地址中。</p>
<pre><code>http://localhost/8080/sessioncookie/otherServlet;jsessionid=6BD1D909077DF0798ASSSJAK8200EC12
</code></pre><p>这样的话，发送请求到OtherServlet时，就会将该sessionid发送到服务端。</p>
<h4 id="2-5-cookie禁用后非重定向跳转时session的跟踪"><a href="#2-5-cookie禁用后非重定向跳转时session的跟踪" class="headerlink" title="2.5 cookie禁用后非重定向跳转时session的跟踪"></a>2.5 cookie禁用后非重定向跳转时session的跟踪</h4><p>HttpServletResponse具有一个方法encdodeURL()，可以完成类似超链接这样的非重定向页面跳转的URL的重写，即在其路径后自动添加jsessionid</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //获取用户提交的数据
    String username = request.getParameter(&quot;username&quot;);

    //获取session对象
    HttpSession session = request.getSession();

    //向session域中写入数据
    session.setAttribute(&quot;username&quot;, username);

    //跳转到otherServlet
    response.setContentType(&quot;text/html;charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
    String uri = &quot;otherServlet&quot;;
    uri = response.encodeURL(uri);
    out.println(&quot;&lt;a href=&apos;&quot; + uri + &quot;&apos;&gt;跳转&lt;/a&gt;到otherservlet&quot;);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/java/java-session-cookie/session-cookie/" data-id="cjh4911m40057mtp3sst7kf5f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/session-cookie/">session cookie</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-jsp/java-jsp-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/java/java-jsp/java-jsp-3/" class="article-date">
  <time datetime="2018-03-07T03:23:34.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/java/java-jsp/java-jsp-3/">第3章 jsp系统开发模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第3章-系统开发模型"><a href="#第3章-系统开发模型" class="headerlink" title="第3章 系统开发模型"></a>第3章 系统开发模型</h3><h4 id="3-1-1-纯jsp"><a href="#3-1-1-纯jsp" class="headerlink" title="3.1.1 纯jsp"></a>3.1.1 纯jsp</h4><h4 id="3-1-2-jsp-javaBean的Model1"><a href="#3-1-2-jsp-javaBean的Model1" class="headerlink" title="3.1.2 jsp+javaBean的Model1"></a>3.1.2 jsp+javaBean的Model1</h4><p>广义的javaBean分为数据承载Bean和业务处理Bean</p>
<p>狭义的javaBean，需要满足javaBean规范。</p>
<ul>
<li>public 修饰</li>
<li>实现Serializable接口</li>
<li>无参构造器</li>
<li>成员变量私有化，且提供getter和setter</li>
</ul>
<h4 id="3-1-3-MVC的Modle2"><a href="#3-1-3-MVC的Modle2" class="headerlink" title="3.1.3 MVC的Modle2"></a>3.1.3 MVC的Modle2</h4><h4 id="3-1-4-三层架构"><a href="#3-1-4-三层架构" class="headerlink" title="3.1.4 三层架构"></a>3.1.4 三层架构</h4><p>View层：视图层、表现层、Web层。</p>
<p>Service层：业务层、逻辑层。</p>
<p>Dao层：持久层、数据访问层。data access object</p>
<p>三层架构的设计中，采用面向抽象编程。即上层对下层的调用，是通过调用接口的方法实现的。而下层对上层真正的服务提供者，是下层接口的实现类。</p>
<p>提供报务的接口相同，服务的实现类可以更换，实现了层间解耦。</p>
<h4 id="3-1-5-MVC-三层架构"><a href="#3-1-5-MVC-三层架构" class="headerlink" title="3.1.5 MVC+三层架构"></a>3.1.5 MVC+三层架构</h4><p>View Level：Contoller(Servlet) + View(jsp)</p>
<p>Service Level：Interfaces + Impls</p>
<p>Dao Level：Interfaces + Impls</p>
<p>将MVC的Model分为了两层：Service层与Dao层，分别用于处理业务逻辑和持久化操作。</p>
<h3 id="3-2-学生注册登录系统"><a href="#3-2-学生注册登录系统" class="headerlink" title="3.2 学生注册登录系统"></a>3.2 学生注册登录系统</h3><p>package: com.test.beans</p>
<p>//定义狭义的javaBean Student</p>
<pre><code>public class Sdudent implements Serializable {

    private static final long serialVersionUID = 1L;
    private Integer id;//业务无关主键
    private String password;
    private String num;//学号
    private String name;
    private String age;
    private double score;
    public Sdudent() {
        super();
    }
    public Sdudent(String num, String name, String age, double score) {
        super();
        this.num = num;
        this.name = name;
        this.age = age;
        this.score = score;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getNum() {
        return num;
    }
    public void setNum(String num) {
        this.num = num;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getAge() {
        return age;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public double getScore() {
        return score;
    }
    public void setScore(double score) {
        this.score = score;
    }
    @Override
    public String toString() {
        return &quot;Sdudent [id=&quot; + id + &quot;, password=&quot; + password + &quot;, num=&quot; + num + &quot;, name=&quot; + name + &quot;, age=&quot; + age
                + &quot;, score=&quot; + score + &quot;]&quot;;
    }

}
</code></pre><p>建表sdudent</p>
<p>//login.jsp 修改欢迎页面为login.jsp</p>
<pre><code>&lt;form action=&quot;${pageContext.request.contextPath }/loginServlet&quot;&gt;
    学号：&lt;input type=&quot;text&quot; name=&quot;num&quot; /&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;
&lt;/form&gt;
&lt;a href=&quot;${pageContext.request.contextPath}/register.jsp&quot;&gt;注册&lt;/a&gt;
</code></pre><p>//register.jsp</p>
<pre><code>${message }&lt;br /&gt;
&lt;form action=&quot;${pageContext.request.contextPath }/registerServlet&quot;&gt;
    学号：&lt;input type=&quot;text&quot; name=&quot;num&quot; /&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;
&lt;/form&gt;
</code></pre><p>//连接数据库，工具类</p>
<pre><code>package com.test.utils;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class JdbcUtils {
    //加载DB驱动
    static {
        //将驱动mysql-connector-java-5.1.7-bin.jar放到lib下
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private static Connection conn;        

    //获取connection对象
    public static Connection getConnection() throws SQLException {

        String url = &quot;jdbc:mysql://127.0.0.1:3306/test&quot;;
        String user = &quot;root&quot;;
        String password = &quot;&quot;;
        if(conn == null || conn.isClosed()) {
            conn = DriverManager.getConnection(url, user, password);
        }
        return conn;

    }

    //关闭资源
    public static void close(Connection conn, Statement stmt, ResultSet rs) throws SQLException {

        if(conn != null &amp;&amp; !conn.isClosed()) {
            conn.close();
        }
        if(stmt != null &amp;&amp; !stmt.isClosed()) {
            stmt.close();
        }
        if(rs != null &amp;&amp; !rs.isClosed()) {
            rs.close();
        }

    }

}
</code></pre><p>//登录的servlet</p>
<pre><code>package com.test.servlets;

public class LoginServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1、接收请求参数
        String num = request.getParameter(&quot;num&quot;);
        String password = request.getParameter(&quot;password&quot;);

        HttpSession session = request.getSession();

        if(num == null || &quot;&quot;.equals(num.trim())) {
            session.setAttribute(&quot;message&quot;, &quot;输入不能为空&quot;);
            response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);
            return;
        }

        //2、创建Service对象
        IStudentService service = new StudentServiceImpl();

        //3、调用Service对象的checkUser验证方法
        Student sdudent = service.checkUser(num, password);

        //4、验证失败，跳转到登录页面
        if(sdudent == null) {
            session.setAttribute(&quot;message&quot;, &quot;输入错误&quot;);
            response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);
            return;
        }

        //5、验证通过，跳转到index.jsp
        response.sendRedirect(request.getContextPath() + &quot;/index.jsp&quot;);

    }
}
</code></pre><p>//注册的servlet</p>
<pre><code>package com.test.servlets;
public class RegisterServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //1、获取表单参数
        request.setCharacterEncoding(&quot;UTF-8&quot;);
        String num = request.getParameter(&quot;num&quot;);
        String password = request.getParameter(&quot;password&quot;);
        String name = request.getParameter(&quot;name&quot;);
        String ageStr = request.getParameter(&quot;age&quot;);
        String scoreStr = request.getParameter(&quot;score&quot;);

        Integer age = Integer.valueOf(ageStr);
        Double score = Double.valueOf(scoreStr);

        //2、创建Student对象
        Student student = new Student(num,name,age,score);
        student.setPassword(password);

        //3、创建Service对象
        IStudentService service = new StudentServiceImpl();

        //4、调用Service对象的saveStudent()方法，写入DB
        Integer id = service.saveStudent(student);

        //5、写入失败，跳转到注册页面，重新注册
        if(id == null) {
            response.sendRedirect(request.getContextPath() + &quot;/register.jsp&quot;);
        }

        //6、写入成功，跳转到登录页面
        response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);
    }

}
</code></pre><p>service层</p>
<p>//服务层接口</p>
<pre><code>package com.test.service;

import com.test.beans.Student;

public interface IStudentService {
    //对登录用户进行验证
    Student checkUser(String num, String password);

    //向DB中添加Student
    Integer saveStudent(Student student);
}
</code></pre><p>//服务层实现类</p>
<pre><code>package com.test.service;

import com.test.beans.Student;
import com.test.dao.IStudentDao;
import com.test.dao.SdudentDaoImpl;

public class StudentServiceImpl implements IStudentService {
    private IStudentDao dao;

    public StudentServiceImpl() {
        dao = new SdudentDaoImpl();
    }

    @Override
    public Student checkUser(String num, String password) {
        return dao.selectStudentLogin(num,password);
    }

    @Override
    public Integer saveStudent(Student student) {
        return dao.insertStudent(student);
    }

}
</code></pre><p>//dao层</p>
<p>//dao层接口</p>
<pre><code>package com.test.dao;

import com.test.beans.Student;

public interface IStudentDao {

    Student selectStudentLogin(String num, String password);

    Integer insertStudent(Student student);

}
</code></pre><p>//dao层实现类</p>
<pre><code>package com.test.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.test.beans.Student;
import com.test.utils.JdbcUtils;

public class SdudentDaoImpl implements IStudentDao {
    private Connection conn;
    private Statement stmt;
    private PreparedStatement ps;
    private ResultSet rs;

    @Override
    public Student selectStudentLogin(String num, String password) {
        Student student = null;
        try {
            conn = JdbcUtils.getConnection();
            String sql = &quot;select * from student where num=? and password=?&quot;;
            ps = conn.prepareStatement(sql);
            ps.setString(1, num);
            ps.setString(2, password);
            rs = ps.executeQuery();
            if(rs.next()) {
                student = new Student();
                student.setId(rs.getInt(&quot;id&quot;));
                student.setNum(rs.getString(&quot;num&quot;));
                student.setPassword(rs.getString(&quot;password&quot;));
                student.setName(rs.getString(&quot;name&quot;));
                student.setAge(rs.getInt(&quot;age&quot;));
                student.setScore(rs.getDouble(&quot;score&quot;));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                JdbcUtils.close(conn, ps, rs);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return student;
    }

    @Override
    public Integer insertStudent(Student student) {
        Integer id = null;
        try {
            conn = JdbcUtils.getConnection();
            String sql = &quot;insert into student(num,password,name,age,score) values(?,?,?,?,?)&quot;;
            ps = conn.prepareStatement(sql);
            ps.setString(1, student.getNum());
            ps.setString(2, student.getPassword());
            ps.setString(3, student.getName());
            ps.setInt(4, student.getAge());
            ps.setDouble(5, student.getScore());

            ps.executeUpdate();

            sql = &quot;select @@identity newId&quot;;
            ps = conn.prepareStatement(sql);
            rs = ps.executeQuery();
            if(rs.next()) {
                id = rs.getInt(&quot;newId&quot;);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                JdbcUtils.close(conn, ps, rs);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return id;
    }

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/java/java-jsp/java-jsp-3/" data-id="cjh4911ky0040mtp3avhg2o1v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-jsp/java-jsp-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/java/java-jsp/java-jsp-2/" class="article-date">
  <time datetime="2018-01-31T11:54:50.000Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/java/java-jsp/java-jsp-2/">第2章 JSP核心</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第2章-JSP核心"><a href="#第2章-JSP核心" class="headerlink" title="第2章 JSP核心"></a>第2章 JSP核心</h3><h3 id="2-1-内置对象"><a href="#2-1-内置对象" class="headerlink" title="2.1 内置对象"></a>2.1 内置对象</h3><h4 id="2-1-1-pageContext"><a href="#2-1-1-pageContext" class="headerlink" title="2.1.1 pageContext"></a>2.1.1 pageContext</h4><p>javax.servlet.jsp.PageContext</p>
<p>页面上下文，具有一个只在当前页面范围的域属性空间，即其具有setAttribute()方法和getAttribute()方法。</p>
<p>EL表达式，访问变量时，只能访问域属性空间内的变量。因此，可以将变量先存放到该域属性空间，或其它三个域属性空间（request、session、application）。</p>
<p>pageContext具有一些get方法，可以获取Request、Response、Session、ServletContext、ServletConfig、page(即当前Servlet)、exception、out等其它八个内置对象</p>
<h4 id="2-1-2-application"><a href="#2-1-2-application" class="headerlink" title="2.1.2 application"></a>2.1.2 application</h4><p>即ServletContext</p>
<p>ServletContext所具有的方法，application都有。</p>
<p>常用的方法，例如：</p>
<p>void setAttribute(String name, Object object);</p>
<p>Object getAttribute(String name);</p>
<p>Object removeAttribute(String name);</p>
<h4 id="2-1-3-out"><a href="#2-1-3-out" class="headerlink" title="2.1.3 out"></a>2.1.3 out</h4><p>所属类型：javax.servlet.jsp.JspWriter</p>
<p>JspWriter类继承自IO流的Writer类。</p>
<p>即out就是一个输出流。</p>
<h4 id="2-1-4-page"><a href="#2-1-4-page" class="headerlink" title="2.1.4 page"></a>2.1.4 page</h4><p>查看jsp翻译的servlet，page对象即Servlet对象本身。</p>
<p>final java.lang.Object page = this.</p>
<h4 id="2-1-5-exception"><a href="#2-1-5-exception" class="headerlink" title="2.1.5 exception"></a>2.1.5 exception</h4><p>普通的jsp页面中，不能使用exception内置对象。因为打开jsp翻译的servlet，发现其中并没有exception对象。</p>
<p>若要在页面中直接使用exception对象，则需要配合着page指令使用。</p>
<h4 id="2-1-6-其它对象"><a href="#2-1-6-其它对象" class="headerlink" title="2.1.6 其它对象"></a>2.1.6 其它对象</h4><p>request,response,session,config，用法与servlet时的用法相同。</p>
<h3 id="2-2-JSP指令-directive"><a href="#2-2-JSP指令-directive" class="headerlink" title="2.2 JSP指令(directive)"></a>2.2 JSP指令(directive)</h3><p>jsp中包含三类指令：</p>
<h5 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h5><h5 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h5><h5 id="taglib标签库指令"><a href="#taglib标签库指令" class="headerlink" title="taglib标签库指令"></a>taglib标签库指令</h5><p>&lt;%@ 指令名称 属性名 = 属性值 属性名 = 属性值 %&gt;</p>
<h4 id="2-1-1-page指令"><a href="#2-1-1-page指令" class="headerlink" title="2.1.1 page指令"></a>2.1.1 page指令</h4><p>（1）、pageEncodeing属性</p>
<p>&lt;%@ page pageEncoding = “utf-8”%&gt;</p>
<p>默认的MIME类型为text/html</p>
<p>//servlet<br>response.setContentType(“text/html;charset=UTF-8”);</p>
<p>(2)、contentType属性</p>
<p>&lt;%@ page contentType = “text/html; charset=UTF-8” %&gt;</p>
<p>//servlet<br>response.setContentType(“text/html;charset=UTF-8”);</p>
<p>可以对pageEncoding默认的MIMe类型进行修改</p>
<p>（3）、import属性</p>
<p>&lt;%@ page import = “java.util.Date”%&gt;</p>
<p>(4)、errorPage\isErrorPage属性</p>
<pre><code>&lt;%@ page errorPage = &quot;/error.jsp&quot; %&gt;
</code></pre><p>//error.jsp</p>
<pre><code>&lt;%@ page isErrorPage = &quot;true&quot;%&gt;
&lt;html&gt;
    &lt;body&gt;
        error page&lt;br /&gt;
        ex = &lt;%=exception.getMessage() %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>//serlvet</p>
<pre><code>public void _jspService(...){
    ...
    java.lang.Throwable exception = ...;
    ...
}
</code></pre><p>(5)、Session属性</p>
<p>//hello1.jsp</p>
<pre><code>&lt;body&gt;
    &lt;%
        session.setAttribute(&quot;user&quot;,&quot;zhangsan&quot;);
    %&gt;
&lt;/body&gt;
</code></pre><p>//servlet</p>
<pre><code>session = pageContext.getSession();

查看源码发现，返回的还是request.getSession()
</code></pre><p>1、    设置</p>
<p>HttpSession session = request.getSession(true);<br>session.setAttribute(…);</p>
<p>设为true，意味着没有session对象时才创建，有则不创建。</p>
<p>2、读取</p>
<p>HttpSession session = request.getSession(false);<br>if(session != null){<br>    session.getAttribute(“…”);<br>}</p>
<p>设为false，意味着获取现有的session对象，如果没有，也不创建。</p>
<p>//hello2.jsp</p>
<pre><code>&lt;%@ page contentType = &quot;text/html; charset = UTF-8&quot;%&gt;
&lt;%-- 清除内置的Session对象 --%&gt;
&lt;%@ page session = &quot;fasle&quot;%&gt;

&lt;body&gt;
    HttpSession session =     request.getSession(false);
    if(session != null){
        String user = (String) session.getAttribute(&quot;user&quot;);
        out.print(&quot;user = &quot; + user);
    }        
&lt;body/&gt;
</code></pre><h4 id="2-2-2-include指令"><a href="#2-2-2-include指令" class="headerlink" title="2.2.2 include指令"></a>2.2.2 include指令</h4><p>(1)、用法</p>
<p>可以包含动态文件也可以包含静态页面文件。</p>
<p>index.jsp</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
    index page before&lt;br /&gt;

    &lt;%@ include file = &quot;/next.jsp&quot;%&gt;

    index page after&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>next.jsp</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
    next page
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>（2）、静态联编</p>
<p>只生成了一个index_jsp.java的servlet源文件，没有生成next_jsp.java文件。</p>
<p>jsp翻译引擎，将include指令包含的next.jsp文件直接翻译到了index.jsp对应的servlet中，形成了一个.java文件。</p>
<p>该包含操作是在编译之前，由jsp翻译引擎完成的，而不是在程序运行期间完成的。</p>
<p>这种包含是一种静态包含，称为静态联编。</p>
<p>整个过程只一个_jspService()方法。也就是说，index.jsp和next.jsp之间是可以相互访问局部变量的。</p>
<h3 id="2-3-JSP动作（Action）"><a href="#2-3-JSP动作（Action）" class="headerlink" title="2.3 JSP动作（Action）"></a>2.3 JSP动作（Action）</h3><p>页面中，应该使用EL表达式、JSTL标签及JSP动作，来代替java代码块、表达式。</p>
<p>JSP动作的语法格式</p>
<p><code>&lt;jsp:动作名称 属性名 = 属性值 属性名 = 属性值 ...&gt;&lt;/jsp:动作名称&gt;</code></p>
<p>或</p>
<p><code>&lt;jsp:动作名称 属性名 = 属性值 属性名 = 属性值 ... /&gt;</code></p>
<p>实际开发中，常用的就两个forward和include。</p>
<p>底层使用的是<code>request.getRequestDispatcher(&quot;&quot;).forward(...)和.include()</code>。</p>
<h4 id="2-3-1-forward动作"><a href="#2-3-1-forward动作" class="headerlink" title="2.3.1 forward动作"></a>2.3.1 forward动作</h4><p>index.jsp</p>
<pre><code>&lt;body&gt;
    index page befor &lt;br /&gt;

    &lt;jsp:forward page=&quot;/next.jsp&quot;&gt;&lt;/jsp:forward&gt;

    index page after &lt;br /&gt;

&lt;body/&gt;
</code></pre><p>next.jsp</p>
<pre><code>&lt;body&gt;
    next page
&lt;/body&gt;
</code></pre><p>forward跳转时，只显示</p>
<pre><code>next page
</code></pre><h4 id="2-3-2-include动作"><a href="#2-3-2-include动作" class="headerlink" title="2.3.2 include动作"></a>2.3.2 include动作</h4><p>index.jsp</p>
<pre><code>&lt;body&gt;
    index page befor &lt;br /&gt;

    &lt;jsp:include page=&quot;/next.jsp&quot;&gt;&lt;/jsp:include&gt;

    index page after &lt;br /&gt;

&lt;body/&gt;
</code></pre><p>next.jsp</p>
<pre><code>&lt;body&gt;
    next page
&lt;/body&gt;
</code></pre><p>include跳转时，全显示</p>
<pre><code>index page befor
next page
index page after 
</code></pre><p>(注)：</p>
<p>生成了两个.java文件：index_jsp.java与left_jsp.java。</p>
<p>这个包含动作是在程序运行过程中，由index_jsp文件中的_jspService()方法通过JspRuntimeLibrary类的include()方法调用了left_jsp文件中的_jspService()方法完成的。</p>
<p>这种在运行期执行的包含，称为动态联编。    </p>
<h3 id="2-4-EL表达式"><a href="#2-4-EL表达式" class="headerlink" title="2.4 EL表达式"></a>2.4 EL表达式</h3><p>Expression Language，表达式语言。</p>
<p>${expression}获取到指定表达式的值。</p>
<h4 id="2-4-1-获取数据"><a href="#2-4-1-获取数据" class="headerlink" title="2.4.1 获取数据"></a>2.4.1 获取数据</h4><p>(1)、EL只能从四大域中获取数据</p>
<p>其查找数据的顺序是，依次按照由小到大的范围，从四大域中查找指定名称的属性值，找到后就不再继续往下查找。</p>
<pre><code>&lt;body&gt;
    &lt;%
        String username = &quot;abc&quot;;
        pageContext.setAttribute(&quot;username&quot;, username);
        request.setAttribute(&quot;username&quot;, username);
        session.setAttribute(&quot;username&quot;, username);
        application.setAttribute(&quot;username&quot;, username);
    %&gt;
    //从四大域属性空间中依次查找
    username = ${username}

&lt;/body&gt;
</code></pre><p>（2）、从指定域中获取数据</p>
<pre><code>//通过EL的内置对象，从指定的域属性空间中查找
username = ${requestScope.username}
</code></pre><p>（3）、访问Bean的属性</p>
<pre><code>&lt;body&gt;
    &lt;%
        School school = new School(&quot;qinghua&quot;,&quot;beijing&quot;);        
        Student studentb = new Student(&quot;zhangsan&quot;,23);
        pageContext.setAttribute(&quot;student&quot;, student);
    %&gt;

    student = ${student}

    name = ${student.name}

    schoolName = ${student.school.sname}

&lt;/body&gt;
</code></pre><p>（4）、获取数组中的元素</p>
<pre><code>&lt;body&gt;

    &lt;%
        String[] names = {&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;};
        pageContext.setAttribute(&quot;names&quot;, names);
    %&gt;

    names[1] = ${names[1]}

    &lt;%
        School[] schools = new School[3];
        schools[0] = new School(&quot;qinghua&quot;, &quot;beijing&quot;);
        schools[1] = new School(&quot;haiyang&quot;, &quot;qingdao&quot;);
        schools[2] = new School(&quot;shanda&quot;, &quot;shandong&quot;);
        pageContext.setAttribute(&quot;chools&quot;, schools);
    %&gt;

    chools[2].sname = ${schools[2].sname}

&lt;/body&gt;
</code></pre><p>（5）、获取List中的元素</p>
<pre><code>EL可以通过索引访问List，但无法访问Set。因为Set中没有索引的概念。

&lt;body&gt;
    &lt;%
        List&lt;String&gt; names = new ArrayList&lt;String&gt;();
        names.add(&quot;zhangsan&quot;);
        names.add(&quot;lisi&quot;);
        names.add(&quot;wangwu&quot;);
        pageContext.setAttribute(&quot;names&quot;,names);
    %&gt;

    names[2] = ${names[2]};

&lt;body/&gt;
</code></pre><p>（6）、获取Map中的元素</p>
<pre><code>&lt;body&gt;
    &lt;%
        Map&lt;String, Object&gt; map = new Map&lt;&gt;();
        map.put(&quot;school&quot;, new School(&quot;qinghua&quot;, &quot;beijing&quot;));
        map.put(&quot;mobile&quot;, &quot;1111111&quot;);
        map.put(&quot;age&quot;, 21);
        pageContext.setAttribute(&quot;map&quot;, map);
    %&gt;

    school.name = ${map.school.sname}

    mobile = ${map.mobile};

    age = ${map.age}；

&lt;/body&gt;
</code></pre><h4 id="2-4-2-运算符"><a href="#2-4-2-运算符" class="headerlink" title="2.4.2 运算符"></a>2.4.2 运算符</h4><p>算术运算符，关系运算符，逻辑运算符，条件运算符，取值运算符</p>
<p>除了这些，还有一个empty</p>
<p>${empty 变量}</p>
<ul>
<li>变量未定义，返回true</li>
<li>变量为String类型，空串返回true</li>
<li>变量为引用类型，其值为null返回true</li>
<li>变量为集合类型，不包含任何元素，返回true</li>
</ul>
<h4 id="2-4-3-EL内置对象"><a href="#2-4-3-EL内置对象" class="headerlink" title="2.4.3 EL内置对象"></a>2.4.3 EL内置对象</h4><p>EL中表示四个域属性空间的内置对象：pageScope requestScope sessionScope applicationScope</p>
<p>其它的常用内置对象还有：</p>
<p>（1）、pageContext</p>
<p>EL中的pageContext与JSP中内置对象中的pageContext是同一个对象。</p>
<p>通过该对象，可以获取request、response、session、servletContext、servletConfig等对象。</p>
<ul>
<li><p><code>${pageContext.request.contextPath}</code>，获取项目根目录，一般用在JSP页面的路径前。</p>
<form action="${pageContext.request.contextPath/register.do}" method="post"><br>   …<br></form>
</li>
<li><p>pageContext.request 其底层实际调用的是pageContext.getRequest()方法</p>
</li>
<li><p>在EL的11个内置对象中，除了pageContext外，其它10个内置对象，其类型均为java.util.Map类型。    </p>
</li>
</ul>
<p>（2）、param</p>
<p>获取请求中指定参数的值</p>
<p>GET: http:localhost:8080/textproject/index.jsp?name=abc</p>
<p>//index.jsp</p>
<p>param.name = ${param.name}</p>
<p>POST:</p>
<pre><code>&lt;form action = &quot;${pageContext.request.contextPath/show.jsp}&quot;&gt;
    姓名：&lt;input type = &quot;text&quot; name = &quot;name&quot; /&gt;
    年龄：&lt;input type = &quot;text&quot; name = &quot;age&quot; /&gt;
    爱好：
    &lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; value = &quot;swimming&quot; /&gt;
    &lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; value = &quot;climbing&quot; /&gt;
    &lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; value = &quot;reading&quot; /&gt;
&lt;/form&gt;
</code></pre><p>//show.jsp</p>
<pre><code>name = ${param.name}
age = ${param.age}
</code></pre><p>（3）、paramValues</p>
<pre><code>hobby[0] = ${paramValues.hobby[0]}
hobby[1] = ${paramValues.hobby[0]}
hobby[2] = ${paramValues.hobby[0]}
</code></pre><p>（4）、initParam</p>
<p>获取web.xml中初始化参数</p>
<p>web.xml</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;company&lt;param-name/&gt;
    &lt;param-value&gt;powernode&lt;param-value/&gt;
&lt;/context-param&gt;
</code></pre><p>jsp页面</p>
<pre><code>company = ${initParam.company}
</code></pre><h4 id="2-4-4-自定义EL函数"><a href="#2-4-4-自定义EL函数" class="headerlink" title="2.4.4 自定义EL函数"></a>2.4.4 自定义EL函数</h4><p>自定义EL函数，实际字符串连接的功能</p>
<p>1、定义类</p>
<pre><code>public class ELFunctions{
    public static String lowerToUpper(String source){
        return source.toUpperCase();
    }

    public static String upperToLower(String source){
        return source.toLowerCase();
    }
}
</code></pre><p>2、标签库定义 注册</p>
<p>自定义的类及其函数，需要在扩展名为.tld的XML文件中进行注册</p>
<p>XML文件是需要约束的，即需要配置文件头部。这个头部约束可以从以下文件中复制。</p>
<p>comcat-9/webapps/examples/web-inf/jsp2/jsp2-example-taglib.tld</p>
<p>//WEB-INF/myElFuns.tld</p>
<pre><code>&lt;tablib ...&gt;

    //定义标签库信息
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;show-name&gt;myElFuncs&lt;/short-name&gt;
    &lt;uri&gt;http://www.test.com/myproject/jsp/el/customElFuncs&lt;/uri&gt;

    //注册函数
    &lt;function&gt;
        &lt;name&gt;myLowerToUpper&lt;/name&gt;
        &lt;function-class&gt;myproject.testpackage. ELFunctions&lt;/function-class&gt;
        &lt;function-signature&gt;java.lang.String. lowerToUpper(java.lang.String)&lt;/function-signature&gt;
    &lt;function/&gt;

    &lt;function&gt;
        &lt;name&gt;myUpperToLower&lt;/name&gt;
        &lt;function-class&gt;myproject.testpackage. ELFunctions&lt;/function-class&gt;
        &lt;function-signature&gt;java.lang.String. upperToLower(java.lang.String)&lt;/function-signature&gt;
    &lt;function/&gt;

&lt;/tablib&gt;
</code></pre><p>//index.jsp</p>
<pre><code>&lt;%@ taglib uri = &quot;http://www.test.com/myproject/jsp/el/customElFuncs&quot; prefix = &quot;myElFuncs&quot;%&gt;
&lt;body&gt;
    ${myElFuncs:myLowerToUpper(&quot;abc&quot;)}
&lt;/body&gt;
</code></pre><h4 id="2-4-5-JSTL中的EL函数"><a href="#2-4-5-JSTL中的EL函数" class="headerlink" title="2.4.5 JSTL中的EL函数"></a>2.4.5 JSTL中的EL函数</h4><p>JSTL，JSP Standard Tag Library，即JSP标准标签库。</p>
<p>该标签库中，定义好了一套处理字符串的函数标签库。</p>
<p>将JSTL的Jar包导入WEb/lib后，在jsp页面中即可直接使用。</p>
<p>//index.jsp</p>
<pre><code>&lt;%@ taglib uri = &quot;http://java.sun.com/jsp/jstl/functions&quot; prefix = &quot;fn&quot;%&gt;

&lt;body&gt;
    ${fun.substring(&quot;abcdefg&quot;, 2, 5)}
    .....
    .....
&lt;/body&gt;
</code></pre><h4 id="2-4-6-EL总结"><a href="#2-4-6-EL总结" class="headerlink" title="2.4.6 EL总结"></a>2.4.6 EL总结</h4><ul>
<li>EL不能出现在java代码块、表达式块等jsp动态代码部分</li>
<li>EL只能从pageContext、request、session、application四大域属性空间中获取数据</li>
<li>EL不会抛出空指针异常</li>
<li>EL不会抛出数组访问越界异常</li>
<li>EL不具有字符串处理能力，只能通过JSTL标签库来处理</li>
</ul>
<h3 id="2-5-自定义标签"><a href="#2-5-自定义标签" class="headerlink" title="2.5 自定义标签"></a>2.5 自定义标签</h3><p>简化代码，替代java代码块。</p>
<h4 id="2-5-1-基本用法"><a href="#2-5-1-基本用法" class="headerlink" title="2.5.1 基本用法"></a>2.5.1 基本用法</h4><p>（1）、需求</p>
<p>自定义标签，输出客户端Ip</p>
<p>（2）、定义标签处理器</p>
<p>实现处理器接口：javax.servlet.jsp.tagext.simpleTag</p>
<pre><code>//定义标签处理器
public class ClientIpTag extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        //获取pageContext
        PageContext pc = (PageContext) this.getJspContext();
        //获取请求对象
        ServletRequest request = pc.getRequest();
        //获取客户端IP
        String clientIp = request.getRemoteAddr();
        //获取标准输出流
        JspWriter out = pc.getOut();
        //输出
        out.print(clientIp);
    }
}
</code></pre><p>（3）、注册标签处理器</p>
<p>//customTags.tld</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;
    version=&quot;2.0&quot;&gt;
    &lt;!--配置标签库信息--&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;short-name&gt;customTags&lt;/short-name&gt;
    &lt;uri&gt;http://www.jstlproject.com/jsp/tags/custom&lt;/uri&gt;
    &lt;!--注册标签--&gt;
    &lt;tag&gt;
        &lt;name&gt;clientIp&lt;/name&gt;
        &lt;tag-class&gt;tags.ClientIpTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;/tag&gt;

&lt;/taglib&gt;
</code></pre><p>（4）、使用自定义标签</p>
<pre><code>&lt;%@ taglib uri = &quot;http://www.jstlproject.com/jsp/tags/custom&quot; prefix = &quot;customTags&quot; %&gt;
&lt;body&gt;
    &lt;% 
        String ip = request.getRemoteAddr();
        out.println(&quot;ip = &quot; + ip);
    %&gt;
    &lt;br/&gt;
    &lt;customTags:clientIp /&gt;
&lt;/body&gt;
</code></pre><h4 id="2-5-2-定义带标签体的标签"><a href="#2-5-2-定义带标签体的标签" class="headerlink" title="2.5.2 定义带标签体的标签"></a>2.5.2 定义带标签体的标签</h4><p>//标签处理器 - 小写变大写</p>
<pre><code>public class LowerToUpperTag extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        //获取标签体对象
        JspFragment jspbody = this.getJspBody();
        //创建字符串输出流
        StringWriter strWriter = new StringWriter();
        //标签体对象写入字符串输出流
        jspbody.invoke(strWriter);
        //字符串输出流中的数据
        String str = strWriter.toString();
        //小写变大写
        str = str.toUpperCase();
        //写入标准输出流
        this.getJspContext().getOut().print(str);
    }
}
</code></pre><p>注册</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;
    version=&quot;2.0&quot;&gt;
    &lt;!--配置标签库信息--&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;short-name&gt;customTags&lt;/short-name&gt;
    &lt;uri&gt;http://www.jstlproject.com/jsp/tags/custom&lt;/uri&gt;
    &lt;!--注册标签--&gt;
    &lt;tag&gt;
        &lt;name&gt;clientIp&lt;/name&gt;
        &lt;tag-class&gt;tags.ClientIpTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;/tag&gt;
    &lt;tag&gt;
        &lt;name&gt;lowerToUpper&lt;/name&gt;
        &lt;tag-class&gt;tags.LowerToUpperTag&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;
    &lt;/tag&gt;

&lt;/taglib&gt;
</code></pre><p>附：<body-content></body-content></p>
<ul>
<li>empty:表示当前标签没有标签体</li>
<li>scriptless：表示当前标签具有标签体，对el表达式解析。</li>
<li>jsp:原样输出，已过时</li>
<li>tagdependent: 原样输出到浏览器，不解析el表达式</li>
</ul>
<p>//index.jsp</p>
<pre><code>&lt;%@ taglib uri = &quot;http://www.jstlproject.com/jsp/tags/custom&quot; prefix = &quot;customTags&quot; %&gt;

&lt;body&gt;

    &lt;%
        String username = &quot;aaa&quot;;
        pageContext.setAttribute(&quot;username&quot;, username);
    %&gt;
    &lt;customTags:lowerToUpper&gt;${username }&lt;/customTags:lowerToUpper&gt;

&lt;/body&gt;
</code></pre><h4 id="2-5-3-定义带属性的标签"><a href="#2-5-3-定义带属性的标签" class="headerlink" title="2.5.3 定义带属性的标签"></a>2.5.3 定义带属性的标签</h4><p>//注册标签</p>
<pre><code>&lt;tag&gt;
    &lt;name&gt;if&lt;/name&gt;
    &lt;tag-class&gt;tags.IfTag&lt;/tag-class&gt;
    &lt;body-content&gt;tagdependent&lt;/body-content&gt;
        &lt;attribute&gt;
            &lt;name&gt;test&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;!-- runtime expression value 
                true:该属性的值支持el表达式与jsp表达式
            --&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
&lt;/tag&gt;
</code></pre><p>//定义标签处理器</p>
<pre><code>public class IfTag extends SimpleTagSupport {
    private boolean test;
    //标签的属性反映到标签处理器中，就是一个set属性
    public void setTest(boolean test) {
        this.test = test;
    }
    @Override
    public void doTag() throws JspException, IOException {
        if(test) {
            /*
            JspFragment jspbody = this.getJspBody();
            jspbody.invoke(this.getJspContext().getOut());
            */
            //以上代码等价于以下代码
            this.getJspBody().invoke(null);
        }
    }
}
</code></pre><p>//index.jsp</p>
<pre><code>&lt;customTages:if test = ${gender} }} }&gt;男&lt;/customTages:if&gt;
&lt;customTages:if test = not gender }&gt;女&lt;/customTages:if&gt;
</code></pre><h4 id="2-5-4-定义forEach标签"><a href="#2-5-4-定义forEach标签" class="headerlink" title="2.5.4 定义forEach标签"></a>2.5.4 定义forEach标签</h4><p>//定义标签处理器，遍历collection集合和数组</p>
<pre><code>public class ForEachTag extends SimpleTagSupport {

    private Object items;
    private String var;

    public void setItems(Object items) {
        this.items = items;
    }    

    public void setVar(String var) {
        this.var = var;
    }

    public Collection getcoll() {
        if(items instanceof List) {
            return (List) items;
        }else if(items instanceof Set) {
            return (Set) items;
        }else if(items instanceof Map) {
            return ((Map) items).entrySet();
        }else if(items instanceof Object[]) {
            return Arrays.asList((Object[])items);
        }
        return null;
    }

    @Override
    public void doTag() throws JspException, IOException {
        for (Object obj:getcoll()) {
            this.getJspContext().setAttribute(var, obj);
            this.getJspBody().invoke(null);
        }
    }

}
</code></pre><p>//注册</p>
<pre><code> &lt;tag&gt;
    &lt;name&gt;forEach&lt;/name&gt;
    &lt;tag-class&gt;tags.ForEachTag&lt;/tag-class&gt;
    &lt;body-content&gt;scriptless&lt;/body-content&gt;
        &lt;attribute&gt;
            &lt;name&gt;items&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
        &lt;attribute&gt;
            &lt;name&gt;var&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
&lt;/tag&gt;
</code></pre><p>//index.jsp</p>
<pre><code>&lt;customTags:forEach items=&quot;${citys}&quot; var=&quot;city&quot;&gt;
    ${city }&lt;br&gt;
&lt;/customTags:forEach&gt;
</code></pre><h4 id="2-5-5-将自定义标签库打包发行"><a href="#2-5-5-将自定义标签库打包发行" class="headerlink" title="2.5.5 将自定义标签库打包发行"></a>2.5.5 将自定义标签库打包发行</h4><p>1、右键export选择jar包，只打包源码。</p>
<p>2、把.tld注册文件，放到jar包里的META-INFO里面。</p>
<p>3、把jar包放到项目的WEB-INF的lib下。</p>
<p>4、jsp页面中导入标签库，就可以直接用了。</p>
<h3 id="2-6-JSTL"><a href="#2-6-JSTL" class="headerlink" title="2.6 JSTL"></a>2.6 JSTL</h3><p>jsp standard tag library，包含五个子库。</p>
<p>核心标签库、格式化标签库、EL函数标签库、SQL操作标签库（过时）、XML操作标签库（过时）。</p>
<p>导入jstl.jar包和standard.jar包</p>
<h4 id="2-6-1-核心标签库"><a href="#2-6-1-核心标签库" class="headerlink" title="2.6.1 核心标签库"></a>2.6.1 核心标签库</h4><p>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a>“ prefix=”c” %&gt;</p>
<p>（1）、c:set</p>
<pre><code>//将变量存放到指定域中
&lt;c:set var=&quot;name&quot; value=&quot;zhangsan&quot; scope=&quot;session&quot;&gt;
name = ${sessionScope.name}

//为Bean的属性赋值
&lt;%
    Student student = new Student();
    pageContext.setAttribute(&quot;student&quot;, student);
%&gt;
&lt;c:set value=&quot;lisi&quot; property=&quot;name&quot; target=&quot;${pageScope.student}&quot;&gt;&lt;/c:set&gt;
student = ${student}

//为map赋值
&lt;%
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    pageContext.setAttribute(&quot;map&quot;, map);
%&gt;
&lt;c:set value=&quot;abc&quot; property=&quot;company&quot; target=&quot;${pageScope.map}&quot;&gt;&lt;/c:set&gt;
map = ${map}
</code></pre><p>（2）、c:remove</p>
<pre><code>//从域属性空间中删除变量
&lt;c:remove var=&quot;school&quot;&gt;
</code></pre><p>（3）、c:out</p>
<pre><code>//输出指定的变量
&lt;c:set var=&quot;city&quot; value=&quot;&lt;h1&gt;beijing&lt;/h1&gt;&quot;&gt;

city1 = &lt;c:out value=&quot;${city}&quot;/&gt;

&lt;br /&gt;

city2 = &lt;c:out value=&quot;${city}&quot; escapeXml=&quot;false&quot; /&gt;

city1对h1标签进行了解析。

city2对h1标签没有进行解析，直接输出。
</code></pre><p>（4）、c:catch</p>
<pre><code>//获取异常信息
&lt;c:catch var=&quot;ex&quot;&gt;
    &lt;%
        int i = 3/0;
    %&gt;
&lt;/c:catch&gt;
</code></pre><p>（5）、c:if</p>
<pre><code>&lt;c:if test=&quot;${user == &quot;zhangsan&quot;}&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;进入系统&lt;/a&gt;
&lt;/c:if&gt;
</code></pre><p>（6）、c:choose</p>
<pre><code>&lt;c:choose&gt;
    &lt;c:when test=&quot;${pagenumber == 1}&quot;&gt;
        第一页
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${pagenumber == 2}&quot;&gt;
        第二页
    &lt;/c:when&gt;
    &lt;c:otherwise&gt;
        第三页
    &lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre><p>（7）、c:forEach</p>
<pre><code>//遍历集合
&lt;c:forEach items=&quot;${citys}&quot; var=&quot;city&quot; begin=&quot;0&quot; end=&quot;7&quot; step=&quot;4&quot;&gt;
    ${city} &lt;br&gt;
&lt;/c:forEach&gt;

//输出行号
&lt;c:forEach items=&quot;${students}&quot; var=&quot;student&quot; varStatus=&quot;vs&quot;&gt;
    &lt;tr class=&quot;${vs.count/2 == 0 ? &apos;even&apos; : &apos;odd&apos;}&quot;&gt;
        &lt;td&gt;${vs.count}&lt;/td&gt;
        &lt;td&gt;${student.name}&lt;/td&gt;
        &lt;td&gt;${student.age}&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre><h4 id="2-6-1-格式化标签库"><a href="#2-6-1-格式化标签库" class="headerlink" title="2.6.1 格式化标签库"></a>2.6.1 格式化标签库</h4><p>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank" rel="external">http://java.sun.com/jsp/jstl/fmt</a>“ prefix=”fmt” %&gt;</p>
<pre><code>&lt;%
    Date now = new Date();
    pageContext.setAttribute(&quot;now&quot;, now);
%&gt;

//格式化日期，输出到浏览器
now = &lt;fmt:formatDate value=&quot;${now}&quot; pattern=&quot;yyyy-MM-dd&quot;&gt;

//格式化日期，将结果放到域中的变量里
&lt;fmt:formatDate value=&quot;${now}&quot; pattern=&quot;yyyy-MM-dd&quot; var=&quot;birth&quot;&gt;
生日：&lt;input type=&quot;text&quot; name=&quot;birthday&quot; value=&quot;${birth}&quot; /&gt;
</code></pre><h4 id="2-6-2-jstl下载"><a href="#2-6-2-jstl下载" class="headerlink" title="2.6.2 jstl下载"></a>2.6.2 jstl下载</h4><p>apache.org –&gt; Tomcat –&gt; Taglibs –&gt; Download</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/31/java/java-jsp/java-jsp-2/" data-id="cjh4911l40044mtp3slki7sza" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/angularjs/">angularjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">bootstrap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collecionsFramework/">collecionsFramework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css-grid/">css-grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsp/">jsp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/regex/">regex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session-cookie/">session cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/足球/">足球</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IO/" style="font-size: 20px;">IO</a> <a href="/tags/angular/" style="font-size: 17.14px;">angular</a> <a href="/tags/api/" style="font-size: 14.29px;">api</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/collecionsFramework/" style="font-size: 15.71px;">collecionsFramework</a> <a href="/tags/css-grid/" style="font-size: 10px;">css-grid</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/jsp/" style="font-size: 12.86px;">jsp</a> <a href="/tags/mybatis/" style="font-size: 17.14px;">mybatis</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/regex/" style="font-size: 10px;">regex</a> <a href="/tags/servlet/" style="font-size: 11.43px;">servlet</a> <a href="/tags/session-cookie/" style="font-size: 10px;">session cookie</a> <a href="/tags/spring/" style="font-size: 18.57px;">spring</a> <a href="/tags/thread/" style="font-size: 11.43px;">thread</a> <a href="/tags/足球/" style="font-size: 10px;">足球</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/13/java/mybatis/mybatis-7/">第七章 MyBatis - 查询缓存</a>
          </li>
        
          <li>
            <a href="/2018/05/12/java/mybatis/mybatis-6/">第六章 MyBatis - 延迟加载</a>
          </li>
        
          <li>
            <a href="/2018/05/12/java/mybatis/mybatis-5/">第五章 MyBatis关联关系查询 - 多对多</a>
          </li>
        
          <li>
            <a href="/2018/05/12/java/mybatis/mybatis-4/">第四章 MyBatis关联关系查询 - 自关联</a>
          </li>
        
          <li>
            <a href="/2018/05/12/java/mybatis/mybatis-3/">第三章 MyBatis关联关系查询 - 多对一</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>