<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java/spring/spring-5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-5/" class="article-date">
  <time datetime="2018-05-05T06:21:51.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-5/">第五章 Spring与AOP 简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="5-1-AOP编程术语"><a href="#5-1-AOP编程术语" class="headerlink" title="5.1 AOP编程术语"></a>5.1 AOP编程术语</h4><h5 id="（1）、切面（Aspect）"><a href="#（1）、切面（Aspect）" class="headerlink" title="（1）、切面（Aspect）"></a>（1）、切面（Aspect）</h5><p>切面泛指交叉业务逻辑。常用的切面有通知与顾问。</p>
<p>实际上就是对主业务逻辑的一种增强。</p>
<h5 id="（2）、织入（Weaving）"><a href="#（2）、织入（Weaving）" class="headerlink" title="（2）、织入（Weaving）"></a>（2）、织入（Weaving）</h5><p>将切面代码插入到目标对象的过程。</p>
<h5 id="（3）、连接点（JoinPoint）"><a href="#（3）、连接点（JoinPoint）" class="headerlink" title="（3）、连接点（JoinPoint）"></a>（3）、连接点（JoinPoint）</h5><p>通常业务中接口中的方法均为连接点。</p>
<h5 id="（4）、切入点（Pointcut）"><a href="#（4）、切入点（Pointcut）" class="headerlink" title="（4）、切入点（Pointcut）"></a>（4）、切入点（Pointcut）</h5><p>指切面具体织入的那个连接点。</p>
<p>被标记为final的方法是不能作为连接点和切入点的。</p>
<h5 id="（5）、目标对象（Target）"><a href="#（5）、目标对象（Target）" class="headerlink" title="（5）、目标对象（Target）"></a>（5）、目标对象（Target）</h5><p>目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。</p>
<p>如StudentServiceImpl等。</p>
<h5 id="（6）、通知（Advice）"><a href="#（6）、通知（Advice）" class="headerlink" title="（6）、通知（Advice）"></a>（6）、通知（Advice）</h5><p>通知是切入的一种实现。通知无法指定切入点，所有方法都会执行。</p>
<p>切入点定义切入的位置，通知定义切入的时间。</p>
<h5 id="7-、顾问（advisor）"><a href="#7-、顾问（advisor）" class="headerlink" title="(7)、顾问（advisor）"></a>(7)、顾问（advisor）</h5><p>顾问是切入的另一种实现。</p>
<p>能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-5/" data-id="cji15cnuj0062u0fy00x2j20g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-4/" class="article-date">
  <time datetime="2018-05-05T03:00:10.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-4/">第四章 Spring与IOC 基于注解的DI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DI-annotation</p>
<p>对于注解DI，不再需要在spring配置文件中声明Bean实例。</p>
<h5 id="（1）、导入AOP的jar包。"><a href="#（1）、导入AOP的jar包。" class="headerlink" title="（1）、导入AOP的jar包。"></a>（1）、导入AOP的jar包。</h5><p>注解的后台实现用到了AOP编程。</p>
<p>####（2）、添加约束头</p>
<p>约束在spring-framework-reference\html\xsd-configuration.html文件中</p>
<h4 id="3-、组件扫描器"><a href="#3-、组件扫描器" class="headerlink" title="(3)、组件扫描器"></a>(3)、组件扫描器</h4><p>配置文件中添加</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bjpowernode.di03&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>Student.class</p>
<pre><code>@Component(&quot;myStudent&quot;)//组件，表示该类被容器所管理
public class Student {
    @Value(&quot;zhangsan&quot;)
    private String name;
    @Value(&quot;23&quot;)
    private int age;

    private School school;

    ...

}
</code></pre><h4 id="4-1-组件扫描器的base-package"><a href="#4-1-组件扫描器的base-package" class="headerlink" title="4.1 组件扫描器的base-package"></a>4.1 组件扫描器的base-package</h4><p>扫描com.bjpowernode这个包及其子包</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bjpowernode&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>扫描com.bjpowernode这个包的子包</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.bjpowernode.*&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><h4 id="4-1-基于注解的DI-Component相关注解"><a href="#4-1-基于注解的DI-Component相关注解" class="headerlink" title="4.1 基于注解的DI - @Component相关注解"></a>4.1 基于注解的DI - @Component相关注解</h4><p>与@Component注解，功能相同但是意义不同的注解还有三个：</p>
<ul>
<li><p>@Repository: 注解在Dao实现类上</p>
</li>
<li><p>@Service: 注解在Service实现类上</p>
</li>
<li><p>@Controller: 注解在SpringMVC的处理器上</p>
</li>
</ul>
<h4 id="4-2-基于注解的DI-Scope"><a href="#4-2-基于注解的DI-Scope" class="headerlink" title="4.2 基于注解的DI - @Scope"></a>4.2 基于注解的DI - @Scope</h4><p>不指定的话，默认也是singleton</p>
<pre><code>@Scope(&quot;prototype&quot;)
@Component(&quot;myStudent&quot;)
public class Student {
    @Value(&quot;zhangsan&quot;)
    private String name;
    @Value(&quot;23&quot;)
    private int age;
</code></pre><h4 id="4-3-基于注解的DI-域属性的注入"><a href="#4-3-基于注解的DI-域属性的注入" class="headerlink" title="4.3 基于注解的DI - 域属性的注入"></a>4.3 基于注解的DI - 域属性的注入</h4><p>byName方式的注入，要求@Autowired与@Qualifier联合使用</p>
<pre><code>@Scope(&quot;prototype&quot;)
@Component(&quot;myStudent&quot;)
public class Student {
    @Value(&quot;zhangsan&quot;)
    private String name;
    @Value(&quot;23&quot;)
    private int age;
    @Autowired
    @Qualifier(&quot;mySchool&quot;)
    private School school;//域属性的注解注入
    ...
}
</code></pre><h4 id="4-3-基于注解的DI-域属性的注入-使用-Resource注解"><a href="#4-3-基于注解的DI-域属性的注入-使用-Resource注解" class="headerlink" title="4.3 基于注解的DI - 域属性的注入 - 使用@Resource注解"></a>4.3 基于注解的DI - 域属性的注入 - 使用@Resource注解</h4><p>@Resource //byType的方式注入</p>
<p>@Resource(name=”mySchool”) //byName方式的注解注入</p>
<pre><code>@Component(&quot;myStudent&quot;)    
public class Student {
    ...
    //@Resource //byType的方式注入
    @Resource(name=&quot;mySchool&quot;) //byName方式的注解注入
    private School school;//域属性的注解注入
    ...
}
</code></pre><h4 id="4-4-基于注解的DI-使用Spring的JUnit4测试"><a href="#4-4-基于注解的DI-使用Spring的JUnit4测试" class="headerlink" title="4.4 基于注解的DI - 使用Spring的JUnit4测试"></a>4.4 基于注解的DI - 使用Spring的JUnit4测试</h4><h5 id="（1）、导入jar包"><a href="#（1）、导入jar包" class="headerlink" title="（1）、导入jar包"></a>（1）、导入jar包</h5><p>spring与junit4的整合jar包：spring-test.4.1.RELEASE.jar</p>
<p>测试类</p>
<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
//指定配置文件
@ContextConfiguration(locations=&quot;classpath:com/bjpowernode/di03/applicationContext.xml&quot;)
public class MyTest {
    //注解注入student
    @Resource(name=&quot;myStudent&quot;)
    private Student student;
    @Test
    public void test01() {
        System.out.println(student.toString());
    }
}
</code></pre><h4 id="4-5-Spring与IOC-DI-XML的优先级要基于注解的DI"><a href="#4-5-Spring与IOC-DI-XML的优先级要基于注解的DI" class="headerlink" title="4.5 Spring与IOC DI-XML的优先级要基于注解的DI"></a>4.5 Spring与IOC DI-XML的优先级要基于注解的DI</h4><p>同时存在基于XML的DI和基于注解的DI，XML的优先级要高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-4/" data-id="cji15cnuq0069u0fy7k6337f2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/java/spring/spring-3/" class="article-date">
  <time datetime="2018-05-05T00:53:03.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/java/spring/spring-3/">第三章 Spring与IOC 基于XML的DI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Bean实例在调用无参构造器创建了空值对象后，就要对Bean对象的属性进行初始化。初始化是由容器自动完成的，称为注入。常用方式分为设值注入和构造注入。</p>
<h4 id="3-1-基于xml-设值注入"><a href="#3-1-基于xml-设值注入" class="headerlink" title="3.1 基于xml-设值注入"></a>3.1 基于xml-设值注入</h4><p>通过set方法注入，基本数据类型用value，引用数据类型用ref。</p>
<p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;mySchool&quot; class=&quot;com.bjpowernode.di01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;school&quot; ref=&quot;mySchool&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>School.class</p>
<pre><code>public class School {
    private String name;
    public void setName(String name) {
        this.name = name;
    }

}
</code></pre><p>Student.class</p>
<pre><code>public class Student {

    private String name;
    private int age;
    private School school;

    public Student() {
        super();
    }

    public void setSchool(School school) {
        this.school = school;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, school=&quot; + school + &quot;]&quot;;
    }

}
</code></pre><h4 id="3-2-基于xml-为集合属性赋值"><a href="#3-2-基于xml-为集合属性赋值" class="headerlink" title="3.2 基于xml-为集合属性赋值"></a>3.2 基于xml-为集合属性赋值</h4><p>Some.class</p>
<pre><code>public class Some {
    private School[] schools;
    private String[] myStrs;
    private List&lt;String&gt; myList;
    private Set&lt;String&gt; mySet;
    private Map&lt;String,Object&gt; myMap;
    private Properties myPros;
    ...
    set 方法
    ...
    @Override
    public String toString() {
        return &quot;Some [schools=&quot; + Arrays.toString(schools) + &quot;, mystrs=&quot; + Arrays.toString(myStrs) + &quot;, myList=&quot;
                + myList + &quot;, mySet=&quot; + mySet + &quot;, myMap=&quot; + myMap + &quot;, myPros=&quot; + myPros + &quot;]&quot;;
    }
}
</code></pre><p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;mySchool1&quot; class=&quot;com.bjpowernode.di02.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;mySchool2&quot; class=&quot;com.bjpowernode.di02.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;北京大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;mySome&quot; class=&quot;com.bjpowernode.di02.Some&quot;&gt;
    &lt;property name=&quot;schools&quot;&gt;
        &lt;array&gt;
            &lt;ref bean=&quot;mySchool1&quot;/&gt;
            &lt;ref bean=&quot;mySchool2&quot;/&gt;
        &lt;/array&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myStrs&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;山东&lt;/value&gt;
            &lt;value&gt;临沂&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;平邑&lt;/value&gt;
            &lt;value&gt;一村&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;

    &lt;property name=&quot;mySet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;一街道&lt;/value&gt;
            &lt;value&gt;二街道&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;mobile&quot; value=&quot;15011111111&quot;&gt;&lt;/entry&gt;
            &lt;entry key=&quot;qq&quot; value=&quot;11111&quot;&gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name=&quot;myPros&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;age&quot;&gt;12&lt;/prop&gt;
            &lt;prop key=&quot;sex&quot;&gt;femal&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-3-基于xml-域属性-自动注入"><a href="#3-3-基于xml-域属性-自动注入" class="headerlink" title="3.3 基于xml-域属性-自动注入"></a>3.3 基于xml-域属性-自动注入</h4><h5 id="3-3-1-基于xml-autowire-quot-byName-quot"><a href="#3-3-1-基于xml-autowire-quot-byName-quot" class="headerlink" title="3.3.1 基于xml-autowire=&quot;byName&quot;"></a>3.3.1 基于xml-<code>autowire=&quot;byName&quot;</code></h5><p>会从容器中查找与Student类中域属性名scholl相同的Bean的id，并将该Bean对象自动注入给该域属性</p>
<pre><code>&lt;bean id=&quot;school&quot; class=&quot;com.bjpowernode.di01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h5 id="3-3-2-基于xml-autowire-quot-byType-quot"><a href="#3-3-2-基于xml-autowire-quot-byType-quot" class="headerlink" title="3.3.2 基于xml-autowire=&quot;byType&quot;"></a>3.3.2 基于xml-<code>autowire=&quot;byType&quot;</code></h5><p>会从容器中查找与Student类中域属性类型School具有is-a关系的Bean，并将该Bean对象自动注入给该域属性</p>
<pre><code>&lt;bean id=&quot;mySchool&quot; class=&quot;com.bjpowernode.di01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;清华大学&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h5 id="3-3-3-基于xml-DI-SPEL注入"><a href="#3-3-3-基于xml-DI-SPEL注入" class="headerlink" title="3.3.3 基于xml-DI-SPEL注入"></a>3.3.3 基于xml-DI-SPEL注入</h5><pre><code>&lt;bean id=&quot;myPerson&quot; class=&quot;com.bjpowernode.di01.Person&quot;&gt;
    &lt;property name=&quot;pname&quot; value=&quot;lisi&quot;&gt;&lt;/property&gt;
    &lt;!-- 通过spring el表达式调用静态方法 --&gt;
    &lt;property name=&quot;page&quot; value=&quot;#{T(java.lang.Math).random() * 50}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.di01.Student&quot;&gt;
    &lt;!-- 调用其它Bean的属性 --&gt;
    &lt;property name=&quot;name&quot; value=&quot;#{myPerson.pname}&quot;&gt;&lt;/property&gt;
    &lt;!-- 运算 --&gt;
    &lt;property name=&quot;age&quot; value=&quot;#{myPerson.page &gt; 25 ? 25 : myPerson.page}&quot;&gt;&lt;/property&gt;
    &lt;!-- 调用其它Bean的成员方法 --&gt;
    &lt;property name=&quot;age&quot; value=&quot;#{myPerson.computeAge()}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-4-为应用指定多个Spring配置文件"><a href="#3-4-为应用指定多个Spring配置文件" class="headerlink" title="3.4 为应用指定多个Spring配置文件"></a>3.4 为应用指定多个Spring配置文件</h4><h5 id="1-、平等关系的配置文件"><a href="#1-、平等关系的配置文件" class="headerlink" title="(1)、平等关系的配置文件"></a>(1)、平等关系的配置文件</h5><p>两个配置文件：</p>
<ul>
<li><p>com/bjpowernode/di01/spring-base.xml</p>
</li>
<li><p>com/bjpowernode/di01/spring-beans.xml</p>
</li>
</ul>
<p>创建容器：</p>
<pre><code>String source01 = &quot;com/bjpowernode/di01/spring-base.xml&quot;;
String source02 = &quot;com/bjpowernode/di01/spring-beans.xml&quot;;
ApplicationContext ac = new ClassPathXmlApplicationContext(source01,source02);
</code></pre><p>通配符</p>
<pre><code>String source = &quot;com/bjpowernode/di01/spring-*.xml&quot;;
ApplicationContext ac = new ClassPathXmlApplicationContext(source);
</code></pre><h5 id="2-、包含关系的配置文件"><a href="#2-、包含关系的配置文件" class="headerlink" title="(2)、包含关系的配置文件"></a>(2)、包含关系的配置文件</h5><p>三个配置文件：</p>
<ul>
<li><p>com/bjpowernode/di01/applicationContext.xml</p>
</li>
<li><p>com/bjpowernode/di01/spring-base.xml</p>
</li>
<li><p>com/bjpowernode/di01/spring-beans.xml</p>
</li>
</ul>
<p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
...
&gt;
   &lt;!--引入其它的配置文件--&gt;     
    &lt;import resource=&quot;classpath:com/bjpowernode/di01/spring-base.xml&quot; /&gt;
    &lt;import resource=&quot;classpath:com/bjpowernode/di01/spring-beans.xml&quot; /&gt;

    &lt;!--通配符--&gt;
    &lt;import resource=&quot;classpath:com/bjpowernode/di01/spring-*.xml&quot; /&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/05/java/spring/spring-3/" data-id="cji15cnum0065u0fyrtyujoje" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/04/java/spring/spring-2/" class="article-date">
  <time datetime="2018-05-04T07:28:48.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/java/spring/spring-2/">第二章 spring与IOC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>控制反转（IOC,Inversion of control），是一个概念，是一种思想。指将传上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。</p>
<p>比较流行的两种实现方式有两种：</p>
<ul>
<li><p>依赖查找：Dependency Lookup, DL，容器提供回调接口与上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于JNDI服务接口（java naming and directory interrface）的查找。</p>
</li>
<li><p>依赖注入：Dependency Injection， DI，程序代码不做定位查找，这些工作由容器自行完成。</p>
</li>
</ul>
<p>依赖注入是目前最优秀的解耦方式。依赖注入让spring的Bean之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合到一起。</p>
<h4 id="2-1-创建spring容器"><a href="#2-1-创建spring容器" class="headerlink" title="2.1 创建spring容器"></a>2.1 创建spring容器</h4><pre><code>public class MyTest {
    @Test
    public void test01() {
        SomeServiceImpl service = new SomeServiceImpl();
        service.doSome();
    }

    @Test
    public void test02() {
        //从当前应用的类路径下查找
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        ISomeService service = (ISomeService) ac.getBean(&quot;myService&quot;);
        service.doSome();
    }

    @Test
    public void test03() {
        //从当前应用的根路径下查找
        ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;);
        ISomeService service = (ISomeService) ac.getBean(&quot;myService&quot;);
        service.doSome();
    }

    @Test
    public void test04() {
        BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));
        ISomeService service = (ISomeService) bf.getBean(&quot;myService&quot;);
        service.doSome();
    }

}
</code></pre><p>applicationContext与BeanFactory两种容器的区别：对于其中的Bean的创建时机不同。</p>
<ul>
<li><p>applicationContext容器在进行初始化时，会将其中的所有Bean对象进行创建。</p>
<p>缺点：占用系统资源（内存、cpu等）</p>
<p>优点：响应速度快</p>
</li>
<li><p>BeanFactory容器中的对象，在容器初始化时并不会创建，而是在真正调用时才会被创建</p>
<p>缺点： 响应速度慢</p>
<p>优点： 不多占用系统资源</p>
</li>
</ul>
<h4 id="2-2-Bean的装配"><a href="#2-2-Bean的装配" class="headerlink" title="2.2 Bean的装配"></a>2.2 Bean的装配</h4><p>Bean的装配，即Bean的创建。</p>
<p>底层应用反射机制，通过调用无参构造器创建的Bean对象。</p>
<h4 id="2-3-动态工厂Bean"><a href="#2-3-动态工厂Bean" class="headerlink" title="2.3 动态工厂Bean"></a>2.3 动态工厂Bean</h4><p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 注册动态工厂 --&gt;
    &lt;bean id=&quot;factory&quot; class=&quot;com.bjpowernode.service.ServiceFactory&quot; /&gt;

    &lt;!-- 注册Service:动态工厂Bean --&gt;
    &lt;bean id=&quot;myService&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getSomeService&quot; /&gt;

&lt;/beans&gt;
</code></pre><p>动态工厂</p>
<pre><code>public class ServiceFactory {
    public ISomeService getSomeService() {
        return new SomeServiceImpl();
    }
}
</code></pre><p>接口</p>
<pre><code>public interface ISomeService {
    void doSome();
}
</code></pre><p>实现类</p>
<pre><code>public class SomeServiceImpl implements ISomeService {

    @Override
    public void doSome() {
        System.out.println(&quot;execute dosome() method&quot;);
    }

}
</code></pre><p>测试类</p>
<p>public class MyTest {</p>
<pre><code>@Test
public void test05() {
    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;);
    ISomeService service = (ISomeService) ac.getBean(&quot;myService&quot;);
    service.doSome();
}
</code></pre><p>}</p>
<h4 id="2-4-静态工厂Bean"><a href="#2-4-静态工厂Bean" class="headerlink" title="2.4 静态工厂Bean"></a>2.4 静态工厂Bean</h4><p>applicationContext.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 注册Service:静态工厂Bean --&gt;
    &lt;bean id=&quot;myService&quot; class=&quot;com.bjpowernode.service.ServiceFactory&quot; factory-method=&quot;getSomeService&quot; /&gt;

&lt;/beans&gt;
</code></pre><p>静态工厂</p>
<pre><code>public class ServiceFactory {
    public static ISomeService getSomeService() {
        return new SomeServiceImpl();
    }
}
</code></pre><h4 id="2-5-Bean的作用域"><a href="#2-5-Bean的作用域" class="headerlink" title="2.5 Bean的作用域"></a>2.5 Bean的作用域</h4><pre><code>&lt;bean id=&quot;myService&quot; class=&quot;com.bjpowernode.service.SomeServiceImpl&quot; scope=&quot;singleton&quot; /&gt;
</code></pre><p><code>scope=&quot;singleton&quot;</code> 单例模式：容器中对象的创建是在Spring容器初始化时就全部创建，是默认值</p>
<p><code>scope=&quot;prototype&quot;</code> 原型模式：容器中对象的创建时机不是在Spring容器初始化时创建，而是在代码中真正访问时才创建</p>
<pre><code>ISomeService service1 = (ISomeService) ac.getBean(&quot;myService&quot;);

ISomeService service2 = (ISomeService) ac.getBean(&quot;myService&quot;);
</code></pre><p>默认，即单例模式下，service1与service2从容器中获取的是同一个对象</p>
<p>原型模式下，service1与service2分别创建新的对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/04/java/spring/spring-2/" data-id="cji15cnug005yu0fykbi6f5fx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/spring/spring-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/04/java/spring/spring-1/" class="article-date">
  <time datetime="2018-05-04T06:33:18.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/java/spring/spring-1/">第一章 spring概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>spring的核心是控制反转（IOC）和面向切面编程（AOP）。</p>
<p>spring的主要作用就是为代码“解耦”，降低代码间的耦合度。</p>
<p>spring根据代码功能特点，将降低耦合度的方式分为了两类：IOC与AOP。<br>IOC使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建使用的对象了。而是由spring容器统一管理，自动“注入”。而AOP使得系统级服务得到了最大复用，且不用由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由spring容器统一完成“织入”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/04/java/spring/spring-1/" data-id="cji15cnu5005nu0fygk3672ek" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-session-cookie/session-cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/27/java/java-session-cookie/session-cookie/" class="article-date">
  <time datetime="2018-04-27T02:12:04.000Z" itemprop="datePublished">2018-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/27/java/java-session-cookie/session-cookie/">session&amp;cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-1-cookie简介"><a href="#1-1-cookie简介" class="headerlink" title="1.1 cookie简介"></a>1.1 cookie简介</h4><p>cookie是1993年由网景公司前雇员发明的一种进行网络会话状态跟踪的技术。</p>
<p>会话是由一组请求与响应组成，是围绕着一种相关事情所进行的请求与响应。所以这些请求与响应之间一定是需要有数据传递的，即需要进行会话状态跟踪。然而HTTP协议是一种无状态协议，在不同的请求之间是无法进行数据传递的。此时就需要一种可以进行请求之间进行数据传递的会话跟踪技术，而cookie就是一种这样的技术。</p>
<p>cookie是由服务器生成，保存在客户端的一种信息载体。这个载体中存放着用记访问该站点的会话状态信息。只在cookie没有被清空，或者cookie没有失效，那么，保存在其中的会话状态就有效。</p>
<p>用户在提交第一次请求后，由服务器生成cookie，并将其封装到响应头中，以响应的形式发送给客户端。客户端接收到这个响应后，将cookie保存到客户端。当客户端再次发送同类请求后（资源路径相同，资源名称不同），在请求中会携带保存在客户端的cookie数据，发送到客户端，由服务器对会话进行跟踪。</p>
<p>cookie技术并不是jvavaweb开发的专属技术，而是属于web开发的技术，是所有web开发语言均支持的技术。</p>
<p>cookie是由若干键值对构成，键值对均为字符串。</p>
<h4 id="1-2-javaEE中的cookie"><a href="#1-2-javaEE中的cookie" class="headerlink" title="1.2 javaEE中的cookie"></a>1.2 javaEE中的cookie</h4><p>在javaEE中的javax.servlet.http包中存在一个类Cookie，就是用于完成会话跟踪的Cookie。其只有一个带参构造器。</p>
<h5 id="默认绑定路径"><a href="#默认绑定路径" class="headerlink" title="默认绑定路径"></a>默认绑定路径</h5><p>访问路径由资源路径与资源名称构成。默认情况下，cookie与访问路径中的资源路径绑定。只要用户发出带有绑定资源路径的请求，则在请求头部，将会自动携带与之绑定的cookie路径。</p>
<h5 id="生成cookie"><a href="#生成cookie" class="headerlink" title="生成cookie"></a>生成cookie</h5><pre><code>public class SomeServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());
        //创建两个Cookie
        Cookie cookie = new Cookie(&quot;company&quot;,&quot;abc&quot;);
        Cookie cookie2 = new Cookie(&quot;teacher&quot;,&quot;def&quot;);

        //指定cookie绑定的资源路径。必须加上项目名称
        cookie.setPath(request.getContextPath() + &quot;/aaa/bbb/ccc&quot;);
        cookie2.setPath(request.getContextPath() + &quot;/ddd/eee/fff&quot;);

        //设置cookie有效期
        //大于0，表示将cookie存放到客户端硬盘
        //小于0，与不设置一样，会将cookie存放到浏览器的缓存
        //等于0，表示cookie一生成，马上失效
        cookie.setMaxAge(60 * 60);
        cookie2.setMaxAge(60 * 60 * 24 * 10);

        //向响应中添加Cookie
        response.addCookie(cookie);
        response.addCookie(cookie2);

    }
}
</code></pre><h5 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h5><pre><code>public class OhterServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());

        Cookie[] cookies = request.getCookies();

        for(Cookie cookie:cookies) {
            System.out.println(cookie.getName() + &quot;===&quot; + cookie.getValue());
            if(cookie.getName().equals(&quot;teacher&quot;) &amp;&amp; cookie.getValue().equals(&quot;aaa&quot;)) {
                //...
            } else {
                //..
            }
        }
    }

}
</code></pre><h4 id="2-1-HttpSession"><a href="#2-1-HttpSession" class="headerlink" title="2.1 HttpSession"></a>2.1 HttpSession</h4><p> session，即会话，是web开发中的一种会话状态跟踪技术。不同的是,cookie是将会话状态保存在了客户端，而session是将会话状态保存在了服务器端。</p>
<p> 在javaweb开发中，session是以javax.servlet.HttpSession的接口对象的形式出现。</p>
<hr>
<p>对于request的getSession()的用法：</p>
<ul>
<li><p>一般情况下，若要向session域中写入数据，则需要使用getSession(true)，即getSession()方法。意味着有老的session用老的，没有老的则创建新的。</p>
</li>
<li><p>若要从session中读取数据，则需要使用getSession(false)。意味着有老的session用老的，没有老的返回null。</p>
</li>
</ul>
<hr>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action = &quot;FirstServlet&quot; method = &quot;POST&quot;&gt;
        用户名：&lt;input type = &quot;text&quot; name = &quot;username&quot; /&gt;
        &lt;input type = &quot;submit&quot; value = &quot;提交&quot; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p> FirstServlet</p>
<pre><code>public class FirstServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取用户提交的数据
        String username = request.getParameter(&quot;username&quot;);

        //将参数放到request域
        request.setAttribute(&quot;user&quot;, username);

        //获取session对象
        HttpSession session = request.getSession();

        //向session域中写入数据
        session.setAttribute(&quot;username&quot;, username);

        response.getWriter().print(&quot;SomeServlet&quot; + username);

    }

}
</code></pre><p>SecondServlet</p>
<pre><code>public class SecondServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //从request域中读取user属性
        Object user = request.getAttribute(&quot;user&quot;);

        //获取session
        HttpSession session = request.getSession(false);

        //从session中读取指定属性
        String username = null;
        if(session != null) {
            username = (String) session.getAttribute(&quot;username&quot;);
        }

        PrintWriter out = response.getWriter();
        out.println(&quot;user = &quot; + user);
        out.println(&quot;username = &quot; + username);
        out.println(&quot;session = &quot; + session);
    }

}
</code></pre><h4 id="2-2-Session的工作原理"><a href="#2-2-Session的工作原理" class="headerlink" title="2.2 Session的工作原理"></a>2.2 Session的工作原理</h4><p>在服务器中系统会为每个会话维护一个Session。不同的会话，对应不同的Session。那么，系统是如何识别Session对象的？即是如何做到在同一个会话过程中，一直使用的是同一个Session对象呢？</p>
<h5 id="（1）、写入Session列表"><a href="#（1）、写入Session列表" class="headerlink" title="（1）、写入Session列表"></a>（1）、写入Session列表</h5><p>服务器对当前应用中的Session是以Map的形式进行管理的，这个Map称为Session列表。该Map的key为一个32位长度的随机串，这个随机串称为JSessionID，value则为Session对象的引用。</p>
<p>当用户每一次提交请求时，服务端Servlet中执行到request.getSession()方法后，会自动生成一个Map.entry对象，key为一个根据某种算法新生成的JSessionID，value则为新创建的HttpSession对象。</p>
<h5 id="2-、服务器生成并发送cookie"><a href="#2-、服务器生成并发送cookie" class="headerlink" title="(2)、服务器生成并发送cookie"></a>(2)、服务器生成并发送cookie</h5><p>在将session信息写入session列表后，系统还会自动将“JSessionID”作为name,这个32位长度的随机串作为value，以cookie的形式存放到响应报头中，并随着响应，将该cookie发送到客户端。</p>
<p><a href="http://localhost:8080/sessioncookie" target="_blank" rel="external">http://localhost:8080/sessioncookie</a><br>提交表单，跳转到FirstServlet后，</p>
<pre><code>Response Headers

Content-Length: 13

Date: Fri, 27 Apr 2018 07:54:40 GMT

Set-Cookie: JSESSIONID=DCCE10CC2F5A6FAE40B716CA91B01EB0; Path=/sessioncookie; HttpOnly
</code></pre><h5 id="3-、客户端接收并发送cookie"><a href="#3-、客户端接收并发送cookie" class="headerlink" title="(3)、客户端接收并发送cookie"></a>(3)、客户端接收并发送cookie</h5><p>客户端接收到这个cookie后会将其存放到浏览器缓存中。即，只要客户端浏览器不关闭，浏览器缓存中的cookie就不会消失。</p>
<p>当用户提交第二次请求时，会将缓存中的这个cookie，伴随着请求的头部信息，一块发送到服务端。</p>
<p>再次发送请求时，<a href="http://localhost:8080/sessioncookie/SecondServlet" target="_blank" rel="external">http://localhost:8080/sessioncookie/SecondServlet</a></p>
<pre><code>Request Headers

...

Cookie: JSESSIONID=DCCE10CC2F5A6FAE40B716CA91B01EB0

Host: localhost:8080
</code></pre><p>（4）、从session列表中查找</p>
<p>服务端从请求中读取到客户端发送来的cookie，并根据cookie的SeesionID的值，从Map中查找相应key所对应的value，即session对象。然后，该session的域属性进行读写操作。</p>
<h4 id="2-3-Session的失效"><a href="#2-3-Session的失效" class="headerlink" title="2.3 Session的失效"></a>2.3 Session的失效</h4><p>若某个session在指定的时间内一直未被访问，那么session将超时，即将失效。</p>
<p>在web.xml中可以通过<code>&lt;session-config /&gt;</code>标签设置session的超时时间，单位为分钟。默认的超时时间为30分钟。时间从最后一次访问开始计时。</p>
<pre><code>&lt;session-config&gt;
    &lt;session-timeout&gt;120&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre><p>若未到超时时间，也可以通过HttpSession中的方法invalide()，使得session失效。</p>
<h4 id="2-4-cookie禁用后的session"><a href="#2-4-cookie禁用后的session" class="headerlink" title="2.4 cookie禁用后的session"></a>2.4 cookie禁用后的session</h4><p>cookie禁用后，从someServlet跳转到otherServlet时，</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取用户提交的数据
        String username = request.getParameter(&quot;username&quot;);

        //获取session对象
        HttpSession session = request.getSession();

        //向session域中写入数据
        session.setAttribute(&quot;username&quot;, username);

        //跳转到otherServlet
        response.sendRedirect(request.getContextPath() + &quot;/otherServlet&quot;);    
    }
</code></pre><p>someServlet发送到客户端的包含有sessionid的cookie并没有被客户端保存，所以在发送otherServlet请求时，没有将该包含有sessionid的cookie发送到服务端，因此otherServlet服务端找不到该session，也就不能读取里面的数据。</p>
<h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>request.encodeRedirectURL()方法</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //获取用户提交的数据
    String username = request.getParameter(&quot;username&quot;);

    //获取session对象
    HttpSession session = request.getSession();

    //向session域中写入数据
    session.setAttribute(&quot;username&quot;, username);

    //跳转到otherServlet
    String uri = request.getContextPath() + &quot;/otherServlet&quot;;
    uri = request.encodeRedirectURL(uri);
    response.sendRedirect(uri);    
}
</code></pre><p>这样的话，跳转到otherServlet时，会将sessionid包含到访问地址中。</p>
<pre><code>http://localhost/8080/sessioncookie/otherServlet;jsessionid=6BD1D909077DF0798ASSSJAK8200EC12
</code></pre><p>这样的话，发送请求到OtherServlet时，就会将该sessionid发送到服务端。</p>
<h4 id="2-5-cookie禁用后非重定向跳转时session的跟踪"><a href="#2-5-cookie禁用后非重定向跳转时session的跟踪" class="headerlink" title="2.5 cookie禁用后非重定向跳转时session的跟踪"></a>2.5 cookie禁用后非重定向跳转时session的跟踪</h4><p>HttpServletResponse具有一个方法encdodeURL()，可以完成类似超链接这样的非重定向页面跳转的URL的重写，即在其路径后自动添加jsessionid</p>
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //获取用户提交的数据
    String username = request.getParameter(&quot;username&quot;);

    //获取session对象
    HttpSession session = request.getSession();

    //向session域中写入数据
    session.setAttribute(&quot;username&quot;, username);

    //跳转到otherServlet
    response.setContentType(&quot;text/html;charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
    String uri = &quot;otherServlet&quot;;
    uri = response.encodeURL(uri);
    out.println(&quot;&lt;a href=&apos;&quot; + uri + &quot;&apos;&gt;跳转&lt;/a&gt;到otherservlet&quot;);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/27/java/java-session-cookie/session-cookie/" data-id="cji15cntb004ku0fyuf3lynpr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/session-cookie/">session cookie</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-jsp/java-jsp-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/java/java-jsp/java-jsp-3/" class="article-date">
  <time datetime="2018-03-07T03:23:34.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/java/java-jsp/java-jsp-3/">第3章 jsp系统开发模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第3章-系统开发模型"><a href="#第3章-系统开发模型" class="headerlink" title="第3章 系统开发模型"></a>第3章 系统开发模型</h3><h4 id="3-1-1-纯jsp"><a href="#3-1-1-纯jsp" class="headerlink" title="3.1.1 纯jsp"></a>3.1.1 纯jsp</h4><h4 id="3-1-2-jsp-javaBean的Model1"><a href="#3-1-2-jsp-javaBean的Model1" class="headerlink" title="3.1.2 jsp+javaBean的Model1"></a>3.1.2 jsp+javaBean的Model1</h4><p>广义的javaBean分为数据承载Bean和业务处理Bean</p>
<p>狭义的javaBean，需要满足javaBean规范。</p>
<ul>
<li>public 修饰</li>
<li>实现Serializable接口</li>
<li>无参构造器</li>
<li>成员变量私有化，且提供getter和setter</li>
</ul>
<h4 id="3-1-3-MVC的Modle2"><a href="#3-1-3-MVC的Modle2" class="headerlink" title="3.1.3 MVC的Modle2"></a>3.1.3 MVC的Modle2</h4><h4 id="3-1-4-三层架构"><a href="#3-1-4-三层架构" class="headerlink" title="3.1.4 三层架构"></a>3.1.4 三层架构</h4><p>View层：视图层、表现层、Web层。</p>
<p>Service层：业务层、逻辑层。</p>
<p>Dao层：持久层、数据访问层。data access object</p>
<p>三层架构的设计中，采用面向抽象编程。即上层对下层的调用，是通过调用接口的方法实现的。而下层对上层真正的服务提供者，是下层接口的实现类。</p>
<p>提供报务的接口相同，服务的实现类可以更换，实现了层间解耦。</p>
<h4 id="3-1-5-MVC-三层架构"><a href="#3-1-5-MVC-三层架构" class="headerlink" title="3.1.5 MVC+三层架构"></a>3.1.5 MVC+三层架构</h4><p>View Level：Contoller(Servlet) + View(jsp)</p>
<p>Service Level：Interfaces + Impls</p>
<p>Dao Level：Interfaces + Impls</p>
<p>将MVC的Model分为了两层：Service层与Dao层，分别用于处理业务逻辑和持久化操作。</p>
<h3 id="3-2-学生注册登录系统"><a href="#3-2-学生注册登录系统" class="headerlink" title="3.2 学生注册登录系统"></a>3.2 学生注册登录系统</h3><p>package: com.test.beans</p>
<p>//定义狭义的javaBean Student</p>
<pre><code>public class Sdudent implements Serializable {

    private static final long serialVersionUID = 1L;
    private Integer id;//业务无关主键
    private String password;
    private String num;//学号
    private String name;
    private String age;
    private double score;
    public Sdudent() {
        super();
    }
    public Sdudent(String num, String name, String age, double score) {
        super();
        this.num = num;
        this.name = name;
        this.age = age;
        this.score = score;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getNum() {
        return num;
    }
    public void setNum(String num) {
        this.num = num;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getAge() {
        return age;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public double getScore() {
        return score;
    }
    public void setScore(double score) {
        this.score = score;
    }
    @Override
    public String toString() {
        return &quot;Sdudent [id=&quot; + id + &quot;, password=&quot; + password + &quot;, num=&quot; + num + &quot;, name=&quot; + name + &quot;, age=&quot; + age
                + &quot;, score=&quot; + score + &quot;]&quot;;
    }

}
</code></pre><p>建表sdudent</p>
<p>//login.jsp 修改欢迎页面为login.jsp</p>
<pre><code>&lt;form action=&quot;${pageContext.request.contextPath }/loginServlet&quot;&gt;
    学号：&lt;input type=&quot;text&quot; name=&quot;num&quot; /&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;
&lt;/form&gt;
&lt;a href=&quot;${pageContext.request.contextPath}/register.jsp&quot;&gt;注册&lt;/a&gt;
</code></pre><p>//register.jsp</p>
<pre><code>${message }&lt;br /&gt;
&lt;form action=&quot;${pageContext.request.contextPath }/registerServlet&quot;&gt;
    学号：&lt;input type=&quot;text&quot; name=&quot;num&quot; /&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;
&lt;/form&gt;
</code></pre><p>//连接数据库，工具类</p>
<pre><code>package com.test.utils;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class JdbcUtils {
    //加载DB驱动
    static {
        //将驱动mysql-connector-java-5.1.7-bin.jar放到lib下
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private static Connection conn;        

    //获取connection对象
    public static Connection getConnection() throws SQLException {

        String url = &quot;jdbc:mysql://127.0.0.1:3306/test&quot;;
        String user = &quot;root&quot;;
        String password = &quot;&quot;;
        if(conn == null || conn.isClosed()) {
            conn = DriverManager.getConnection(url, user, password);
        }
        return conn;

    }

    //关闭资源
    public static void close(Connection conn, Statement stmt, ResultSet rs) throws SQLException {

        if(conn != null &amp;&amp; !conn.isClosed()) {
            conn.close();
        }
        if(stmt != null &amp;&amp; !stmt.isClosed()) {
            stmt.close();
        }
        if(rs != null &amp;&amp; !rs.isClosed()) {
            rs.close();
        }

    }

}
</code></pre><p>//登录的servlet</p>
<pre><code>package com.test.servlets;

public class LoginServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1、接收请求参数
        String num = request.getParameter(&quot;num&quot;);
        String password = request.getParameter(&quot;password&quot;);

        HttpSession session = request.getSession();

        if(num == null || &quot;&quot;.equals(num.trim())) {
            session.setAttribute(&quot;message&quot;, &quot;输入不能为空&quot;);
            response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);
            return;
        }

        //2、创建Service对象
        IStudentService service = new StudentServiceImpl();

        //3、调用Service对象的checkUser验证方法
        Student sdudent = service.checkUser(num, password);

        //4、验证失败，跳转到登录页面
        if(sdudent == null) {
            session.setAttribute(&quot;message&quot;, &quot;输入错误&quot;);
            response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);
            return;
        }

        //5、验证通过，跳转到index.jsp
        response.sendRedirect(request.getContextPath() + &quot;/index.jsp&quot;);

    }
}
</code></pre><p>//注册的servlet</p>
<pre><code>package com.test.servlets;
public class RegisterServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //1、获取表单参数
        request.setCharacterEncoding(&quot;UTF-8&quot;);
        String num = request.getParameter(&quot;num&quot;);
        String password = request.getParameter(&quot;password&quot;);
        String name = request.getParameter(&quot;name&quot;);
        String ageStr = request.getParameter(&quot;age&quot;);
        String scoreStr = request.getParameter(&quot;score&quot;);

        Integer age = Integer.valueOf(ageStr);
        Double score = Double.valueOf(scoreStr);

        //2、创建Student对象
        Student student = new Student(num,name,age,score);
        student.setPassword(password);

        //3、创建Service对象
        IStudentService service = new StudentServiceImpl();

        //4、调用Service对象的saveStudent()方法，写入DB
        Integer id = service.saveStudent(student);

        //5、写入失败，跳转到注册页面，重新注册
        if(id == null) {
            response.sendRedirect(request.getContextPath() + &quot;/register.jsp&quot;);
        }

        //6、写入成功，跳转到登录页面
        response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);
    }

}
</code></pre><p>service层</p>
<p>//服务层接口</p>
<pre><code>package com.test.service;

import com.test.beans.Student;

public interface IStudentService {
    //对登录用户进行验证
    Student checkUser(String num, String password);

    //向DB中添加Student
    Integer saveStudent(Student student);
}
</code></pre><p>//服务层实现类</p>
<pre><code>package com.test.service;

import com.test.beans.Student;
import com.test.dao.IStudentDao;
import com.test.dao.SdudentDaoImpl;

public class StudentServiceImpl implements IStudentService {
    private IStudentDao dao;

    public StudentServiceImpl() {
        dao = new SdudentDaoImpl();
    }

    @Override
    public Student checkUser(String num, String password) {
        return dao.selectStudentLogin(num,password);
    }

    @Override
    public Integer saveStudent(Student student) {
        return dao.insertStudent(student);
    }

}
</code></pre><p>//dao层</p>
<p>//dao层接口</p>
<pre><code>package com.test.dao;

import com.test.beans.Student;

public interface IStudentDao {

    Student selectStudentLogin(String num, String password);

    Integer insertStudent(Student student);

}
</code></pre><p>//dao层实现类</p>
<pre><code>package com.test.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.test.beans.Student;
import com.test.utils.JdbcUtils;

public class SdudentDaoImpl implements IStudentDao {
    private Connection conn;
    private Statement stmt;
    private PreparedStatement ps;
    private ResultSet rs;

    @Override
    public Student selectStudentLogin(String num, String password) {
        Student student = null;
        try {
            conn = JdbcUtils.getConnection();
            String sql = &quot;select * from student where num=? and password=?&quot;;
            ps = conn.prepareStatement(sql);
            ps.setString(1, num);
            ps.setString(2, password);
            rs = ps.executeQuery();
            if(rs.next()) {
                student = new Student();
                student.setId(rs.getInt(&quot;id&quot;));
                student.setNum(rs.getString(&quot;num&quot;));
                student.setPassword(rs.getString(&quot;password&quot;));
                student.setName(rs.getString(&quot;name&quot;));
                student.setAge(rs.getInt(&quot;age&quot;));
                student.setScore(rs.getDouble(&quot;score&quot;));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                JdbcUtils.close(conn, ps, rs);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return student;
    }

    @Override
    public Integer insertStudent(Student student) {
        Integer id = null;
        try {
            conn = JdbcUtils.getConnection();
            String sql = &quot;insert into student(num,password,name,age,score) values(?,?,?,?,?)&quot;;
            ps = conn.prepareStatement(sql);
            ps.setString(1, student.getNum());
            ps.setString(2, student.getPassword());
            ps.setString(3, student.getName());
            ps.setInt(4, student.getAge());
            ps.setDouble(5, student.getScore());

            ps.executeUpdate();

            sql = &quot;select @@identity newId&quot;;
            ps = conn.prepareStatement(sql);
            rs = ps.executeQuery();
            if(rs.next()) {
                id = rs.getInt(&quot;newId&quot;);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                JdbcUtils.close(conn, ps, rs);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return id;
    }

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/java/java-jsp/java-jsp-3/" data-id="cji15cnsx0043u0fy7a9cjiw0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-jsp/java-jsp-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/java/java-jsp/java-jsp-2/" class="article-date">
  <time datetime="2018-01-31T11:54:50.000Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/java/java-jsp/java-jsp-2/">第2章 JSP核心</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第2章-JSP核心"><a href="#第2章-JSP核心" class="headerlink" title="第2章 JSP核心"></a>第2章 JSP核心</h3><h3 id="2-1-内置对象"><a href="#2-1-内置对象" class="headerlink" title="2.1 内置对象"></a>2.1 内置对象</h3><h4 id="2-1-1-pageContext"><a href="#2-1-1-pageContext" class="headerlink" title="2.1.1 pageContext"></a>2.1.1 pageContext</h4><p>javax.servlet.jsp.PageContext</p>
<p>页面上下文，具有一个只在当前页面范围的域属性空间，即其具有setAttribute()方法和getAttribute()方法。</p>
<p>EL表达式，访问变量时，只能访问域属性空间内的变量。因此，可以将变量先存放到该域属性空间，或其它三个域属性空间（request、session、application）。</p>
<p>pageContext具有一些get方法，可以获取Request、Response、Session、ServletContext、ServletConfig、page(即当前Servlet)、exception、out等其它八个内置对象</p>
<h4 id="2-1-2-application"><a href="#2-1-2-application" class="headerlink" title="2.1.2 application"></a>2.1.2 application</h4><p>即ServletContext</p>
<p>ServletContext所具有的方法，application都有。</p>
<p>常用的方法，例如：</p>
<p>void setAttribute(String name, Object object);</p>
<p>Object getAttribute(String name);</p>
<p>Object removeAttribute(String name);</p>
<h4 id="2-1-3-out"><a href="#2-1-3-out" class="headerlink" title="2.1.3 out"></a>2.1.3 out</h4><p>所属类型：javax.servlet.jsp.JspWriter</p>
<p>JspWriter类继承自IO流的Writer类。</p>
<p>即out就是一个输出流。</p>
<h4 id="2-1-4-page"><a href="#2-1-4-page" class="headerlink" title="2.1.4 page"></a>2.1.4 page</h4><p>查看jsp翻译的servlet，page对象即Servlet对象本身。</p>
<p>final java.lang.Object page = this.</p>
<h4 id="2-1-5-exception"><a href="#2-1-5-exception" class="headerlink" title="2.1.5 exception"></a>2.1.5 exception</h4><p>普通的jsp页面中，不能使用exception内置对象。因为打开jsp翻译的servlet，发现其中并没有exception对象。</p>
<p>若要在页面中直接使用exception对象，则需要配合着page指令使用。</p>
<h4 id="2-1-6-其它对象"><a href="#2-1-6-其它对象" class="headerlink" title="2.1.6 其它对象"></a>2.1.6 其它对象</h4><p>request,response,session,config，用法与servlet时的用法相同。</p>
<h3 id="2-2-JSP指令-directive"><a href="#2-2-JSP指令-directive" class="headerlink" title="2.2 JSP指令(directive)"></a>2.2 JSP指令(directive)</h3><p>jsp中包含三类指令：</p>
<h5 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h5><h5 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h5><h5 id="taglib标签库指令"><a href="#taglib标签库指令" class="headerlink" title="taglib标签库指令"></a>taglib标签库指令</h5><p>&lt;%@ 指令名称 属性名 = 属性值 属性名 = 属性值 %&gt;</p>
<h4 id="2-1-1-page指令"><a href="#2-1-1-page指令" class="headerlink" title="2.1.1 page指令"></a>2.1.1 page指令</h4><p>（1）、pageEncodeing属性</p>
<p>&lt;%@ page pageEncoding = “utf-8”%&gt;</p>
<p>默认的MIME类型为text/html</p>
<p>//servlet<br>response.setContentType(“text/html;charset=UTF-8”);</p>
<p>(2)、contentType属性</p>
<p>&lt;%@ page contentType = “text/html; charset=UTF-8” %&gt;</p>
<p>//servlet<br>response.setContentType(“text/html;charset=UTF-8”);</p>
<p>可以对pageEncoding默认的MIMe类型进行修改</p>
<p>（3）、import属性</p>
<p>&lt;%@ page import = “java.util.Date”%&gt;</p>
<p>(4)、errorPage\isErrorPage属性</p>
<pre><code>&lt;%@ page errorPage = &quot;/error.jsp&quot; %&gt;
</code></pre><p>//error.jsp</p>
<pre><code>&lt;%@ page isErrorPage = &quot;true&quot;%&gt;
&lt;html&gt;
    &lt;body&gt;
        error page&lt;br /&gt;
        ex = &lt;%=exception.getMessage() %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>//serlvet</p>
<pre><code>public void _jspService(...){
    ...
    java.lang.Throwable exception = ...;
    ...
}
</code></pre><p>(5)、Session属性</p>
<p>//hello1.jsp</p>
<pre><code>&lt;body&gt;
    &lt;%
        session.setAttribute(&quot;user&quot;,&quot;zhangsan&quot;);
    %&gt;
&lt;/body&gt;
</code></pre><p>//servlet</p>
<pre><code>session = pageContext.getSession();

查看源码发现，返回的还是request.getSession()
</code></pre><p>1、    设置</p>
<p>HttpSession session = request.getSession(true);<br>session.setAttribute(…);</p>
<p>设为true，意味着没有session对象时才创建，有则不创建。</p>
<p>2、读取</p>
<p>HttpSession session = request.getSession(false);<br>if(session != null){<br>    session.getAttribute(“…”);<br>}</p>
<p>设为false，意味着获取现有的session对象，如果没有，也不创建。</p>
<p>//hello2.jsp</p>
<pre><code>&lt;%@ page contentType = &quot;text/html; charset = UTF-8&quot;%&gt;
&lt;%-- 清除内置的Session对象 --%&gt;
&lt;%@ page session = &quot;fasle&quot;%&gt;

&lt;body&gt;
    HttpSession session =     request.getSession(false);
    if(session != null){
        String user = (String) session.getAttribute(&quot;user&quot;);
        out.print(&quot;user = &quot; + user);
    }        
&lt;body/&gt;
</code></pre><h4 id="2-2-2-include指令"><a href="#2-2-2-include指令" class="headerlink" title="2.2.2 include指令"></a>2.2.2 include指令</h4><p>(1)、用法</p>
<p>可以包含动态文件也可以包含静态页面文件。</p>
<p>index.jsp</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
    index page before&lt;br /&gt;

    &lt;%@ include file = &quot;/next.jsp&quot;%&gt;

    index page after&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>next.jsp</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
    next page
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>（2）、静态联编</p>
<p>只生成了一个index_jsp.java的servlet源文件，没有生成next_jsp.java文件。</p>
<p>jsp翻译引擎，将include指令包含的next.jsp文件直接翻译到了index.jsp对应的servlet中，形成了一个.java文件。</p>
<p>该包含操作是在编译之前，由jsp翻译引擎完成的，而不是在程序运行期间完成的。</p>
<p>这种包含是一种静态包含，称为静态联编。</p>
<p>整个过程只一个_jspService()方法。也就是说，index.jsp和next.jsp之间是可以相互访问局部变量的。</p>
<h3 id="2-3-JSP动作（Action）"><a href="#2-3-JSP动作（Action）" class="headerlink" title="2.3 JSP动作（Action）"></a>2.3 JSP动作（Action）</h3><p>页面中，应该使用EL表达式、JSTL标签及JSP动作，来代替java代码块、表达式。</p>
<p>JSP动作的语法格式</p>
<p><code>&lt;jsp:动作名称 属性名 = 属性值 属性名 = 属性值 ...&gt;&lt;/jsp:动作名称&gt;</code></p>
<p>或</p>
<p><code>&lt;jsp:动作名称 属性名 = 属性值 属性名 = 属性值 ... /&gt;</code></p>
<p>实际开发中，常用的就两个forward和include。</p>
<p>底层使用的是<code>request.getRequestDispatcher(&quot;&quot;).forward(...)和.include()</code>。</p>
<h4 id="2-3-1-forward动作"><a href="#2-3-1-forward动作" class="headerlink" title="2.3.1 forward动作"></a>2.3.1 forward动作</h4><p>index.jsp</p>
<pre><code>&lt;body&gt;
    index page befor &lt;br /&gt;

    &lt;jsp:forward page=&quot;/next.jsp&quot;&gt;&lt;/jsp:forward&gt;

    index page after &lt;br /&gt;

&lt;body/&gt;
</code></pre><p>next.jsp</p>
<pre><code>&lt;body&gt;
    next page
&lt;/body&gt;
</code></pre><p>forward跳转时，只显示</p>
<pre><code>next page
</code></pre><h4 id="2-3-2-include动作"><a href="#2-3-2-include动作" class="headerlink" title="2.3.2 include动作"></a>2.3.2 include动作</h4><p>index.jsp</p>
<pre><code>&lt;body&gt;
    index page befor &lt;br /&gt;

    &lt;jsp:include page=&quot;/next.jsp&quot;&gt;&lt;/jsp:include&gt;

    index page after &lt;br /&gt;

&lt;body/&gt;
</code></pre><p>next.jsp</p>
<pre><code>&lt;body&gt;
    next page
&lt;/body&gt;
</code></pre><p>include跳转时，全显示</p>
<pre><code>index page befor
next page
index page after 
</code></pre><p>(注)：</p>
<p>生成了两个.java文件：index_jsp.java与left_jsp.java。</p>
<p>这个包含动作是在程序运行过程中，由index_jsp文件中的_jspService()方法通过JspRuntimeLibrary类的include()方法调用了left_jsp文件中的_jspService()方法完成的。</p>
<p>这种在运行期执行的包含，称为动态联编。    </p>
<h3 id="2-4-EL表达式"><a href="#2-4-EL表达式" class="headerlink" title="2.4 EL表达式"></a>2.4 EL表达式</h3><p>Expression Language，表达式语言。</p>
<p>${expression}获取到指定表达式的值。</p>
<h4 id="2-4-1-获取数据"><a href="#2-4-1-获取数据" class="headerlink" title="2.4.1 获取数据"></a>2.4.1 获取数据</h4><p>(1)、EL只能从四大域中获取数据</p>
<p>其查找数据的顺序是，依次按照由小到大的范围，从四大域中查找指定名称的属性值，找到后就不再继续往下查找。</p>
<pre><code>&lt;body&gt;
    &lt;%
        String username = &quot;abc&quot;;
        pageContext.setAttribute(&quot;username&quot;, username);
        request.setAttribute(&quot;username&quot;, username);
        session.setAttribute(&quot;username&quot;, username);
        application.setAttribute(&quot;username&quot;, username);
    %&gt;
    //从四大域属性空间中依次查找
    username = ${username}

&lt;/body&gt;
</code></pre><p>（2）、从指定域中获取数据</p>
<pre><code>//通过EL的内置对象，从指定的域属性空间中查找
username = ${requestScope.username}
</code></pre><p>（3）、访问Bean的属性</p>
<pre><code>&lt;body&gt;
    &lt;%
        School school = new School(&quot;qinghua&quot;,&quot;beijing&quot;);        
        Student studentb = new Student(&quot;zhangsan&quot;,23);
        pageContext.setAttribute(&quot;student&quot;, student);
    %&gt;

    student = ${student}

    name = ${student.name}

    schoolName = ${student.school.sname}

&lt;/body&gt;
</code></pre><p>（4）、获取数组中的元素</p>
<pre><code>&lt;body&gt;

    &lt;%
        String[] names = {&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;};
        pageContext.setAttribute(&quot;names&quot;, names);
    %&gt;

    names[1] = ${names[1]}

    &lt;%
        School[] schools = new School[3];
        schools[0] = new School(&quot;qinghua&quot;, &quot;beijing&quot;);
        schools[1] = new School(&quot;haiyang&quot;, &quot;qingdao&quot;);
        schools[2] = new School(&quot;shanda&quot;, &quot;shandong&quot;);
        pageContext.setAttribute(&quot;chools&quot;, schools);
    %&gt;

    chools[2].sname = ${schools[2].sname}

&lt;/body&gt;
</code></pre><p>（5）、获取List中的元素</p>
<pre><code>EL可以通过索引访问List，但无法访问Set。因为Set中没有索引的概念。

&lt;body&gt;
    &lt;%
        List&lt;String&gt; names = new ArrayList&lt;String&gt;();
        names.add(&quot;zhangsan&quot;);
        names.add(&quot;lisi&quot;);
        names.add(&quot;wangwu&quot;);
        pageContext.setAttribute(&quot;names&quot;,names);
    %&gt;

    names[2] = ${names[2]};

&lt;body/&gt;
</code></pre><p>（6）、获取Map中的元素</p>
<pre><code>&lt;body&gt;
    &lt;%
        Map&lt;String, Object&gt; map = new Map&lt;&gt;();
        map.put(&quot;school&quot;, new School(&quot;qinghua&quot;, &quot;beijing&quot;));
        map.put(&quot;mobile&quot;, &quot;1111111&quot;);
        map.put(&quot;age&quot;, 21);
        pageContext.setAttribute(&quot;map&quot;, map);
    %&gt;

    school.name = ${map.school.sname}

    mobile = ${map.mobile};

    age = ${map.age}；

&lt;/body&gt;
</code></pre><h4 id="2-4-2-运算符"><a href="#2-4-2-运算符" class="headerlink" title="2.4.2 运算符"></a>2.4.2 运算符</h4><p>算术运算符，关系运算符，逻辑运算符，条件运算符，取值运算符</p>
<p>除了这些，还有一个empty</p>
<p>${empty 变量}</p>
<ul>
<li>变量未定义，返回true</li>
<li>变量为String类型，空串返回true</li>
<li>变量为引用类型，其值为null返回true</li>
<li>变量为集合类型，不包含任何元素，返回true</li>
</ul>
<h4 id="2-4-3-EL内置对象"><a href="#2-4-3-EL内置对象" class="headerlink" title="2.4.3 EL内置对象"></a>2.4.3 EL内置对象</h4><p>EL中表示四个域属性空间的内置对象：pageScope requestScope sessionScope applicationScope</p>
<p>其它的常用内置对象还有：</p>
<p>（1）、pageContext</p>
<p>EL中的pageContext与JSP中内置对象中的pageContext是同一个对象。</p>
<p>通过该对象，可以获取request、response、session、servletContext、servletConfig等对象。</p>
<ul>
<li><p><code>${pageContext.request.contextPath}</code>，获取项目根目录，一般用在JSP页面的路径前。</p>
<form action="${pageContext.request.contextPath/register.do}" method="post"><br>   …<br></form>
</li>
<li><p>pageContext.request 其底层实际调用的是pageContext.getRequest()方法</p>
</li>
<li><p>在EL的11个内置对象中，除了pageContext外，其它10个内置对象，其类型均为java.util.Map类型。    </p>
</li>
</ul>
<p>（2）、param</p>
<p>获取请求中指定参数的值</p>
<p>GET: http:localhost:8080/textproject/index.jsp?name=abc</p>
<p>//index.jsp</p>
<p>param.name = ${param.name}</p>
<p>POST:</p>
<pre><code>&lt;form action = &quot;${pageContext.request.contextPath/show.jsp}&quot;&gt;
    姓名：&lt;input type = &quot;text&quot; name = &quot;name&quot; /&gt;
    年龄：&lt;input type = &quot;text&quot; name = &quot;age&quot; /&gt;
    爱好：
    &lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; value = &quot;swimming&quot; /&gt;
    &lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; value = &quot;climbing&quot; /&gt;
    &lt;input type = &quot;checkbox&quot; name = &quot;hobby&quot; value = &quot;reading&quot; /&gt;
&lt;/form&gt;
</code></pre><p>//show.jsp</p>
<pre><code>name = ${param.name}
age = ${param.age}
</code></pre><p>（3）、paramValues</p>
<pre><code>hobby[0] = ${paramValues.hobby[0]}
hobby[1] = ${paramValues.hobby[0]}
hobby[2] = ${paramValues.hobby[0]}
</code></pre><p>（4）、initParam</p>
<p>获取web.xml中初始化参数</p>
<p>web.xml</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;company&lt;param-name/&gt;
    &lt;param-value&gt;powernode&lt;param-value/&gt;
&lt;/context-param&gt;
</code></pre><p>jsp页面</p>
<pre><code>company = ${initParam.company}
</code></pre><h4 id="2-4-4-自定义EL函数"><a href="#2-4-4-自定义EL函数" class="headerlink" title="2.4.4 自定义EL函数"></a>2.4.4 自定义EL函数</h4><p>自定义EL函数，实际字符串连接的功能</p>
<p>1、定义类</p>
<pre><code>public class ELFunctions{
    public static String lowerToUpper(String source){
        return source.toUpperCase();
    }

    public static String upperToLower(String source){
        return source.toLowerCase();
    }
}
</code></pre><p>2、标签库定义 注册</p>
<p>自定义的类及其函数，需要在扩展名为.tld的XML文件中进行注册</p>
<p>XML文件是需要约束的，即需要配置文件头部。这个头部约束可以从以下文件中复制。</p>
<p>comcat-9/webapps/examples/web-inf/jsp2/jsp2-example-taglib.tld</p>
<p>//WEB-INF/myElFuns.tld</p>
<pre><code>&lt;tablib ...&gt;

    //定义标签库信息
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;show-name&gt;myElFuncs&lt;/short-name&gt;
    &lt;uri&gt;http://www.test.com/myproject/jsp/el/customElFuncs&lt;/uri&gt;

    //注册函数
    &lt;function&gt;
        &lt;name&gt;myLowerToUpper&lt;/name&gt;
        &lt;function-class&gt;myproject.testpackage. ELFunctions&lt;/function-class&gt;
        &lt;function-signature&gt;java.lang.String. lowerToUpper(java.lang.String)&lt;/function-signature&gt;
    &lt;function/&gt;

    &lt;function&gt;
        &lt;name&gt;myUpperToLower&lt;/name&gt;
        &lt;function-class&gt;myproject.testpackage. ELFunctions&lt;/function-class&gt;
        &lt;function-signature&gt;java.lang.String. upperToLower(java.lang.String)&lt;/function-signature&gt;
    &lt;function/&gt;

&lt;/tablib&gt;
</code></pre><p>//index.jsp</p>
<pre><code>&lt;%@ taglib uri = &quot;http://www.test.com/myproject/jsp/el/customElFuncs&quot; prefix = &quot;myElFuncs&quot;%&gt;
&lt;body&gt;
    ${myElFuncs:myLowerToUpper(&quot;abc&quot;)}
&lt;/body&gt;
</code></pre><h4 id="2-4-5-JSTL中的EL函数"><a href="#2-4-5-JSTL中的EL函数" class="headerlink" title="2.4.5 JSTL中的EL函数"></a>2.4.5 JSTL中的EL函数</h4><p>JSTL，JSP Standard Tag Library，即JSP标准标签库。</p>
<p>该标签库中，定义好了一套处理字符串的函数标签库。</p>
<p>将JSTL的Jar包导入WEb/lib后，在jsp页面中即可直接使用。</p>
<p>//index.jsp</p>
<pre><code>&lt;%@ taglib uri = &quot;http://java.sun.com/jsp/jstl/functions&quot; prefix = &quot;fn&quot;%&gt;

&lt;body&gt;
    ${fun.substring(&quot;abcdefg&quot;, 2, 5)}
    .....
    .....
&lt;/body&gt;
</code></pre><h4 id="2-4-6-EL总结"><a href="#2-4-6-EL总结" class="headerlink" title="2.4.6 EL总结"></a>2.4.6 EL总结</h4><ul>
<li>EL不能出现在java代码块、表达式块等jsp动态代码部分</li>
<li>EL只能从pageContext、request、session、application四大域属性空间中获取数据</li>
<li>EL不会抛出空指针异常</li>
<li>EL不会抛出数组访问越界异常</li>
<li>EL不具有字符串处理能力，只能通过JSTL标签库来处理</li>
</ul>
<h3 id="2-5-自定义标签"><a href="#2-5-自定义标签" class="headerlink" title="2.5 自定义标签"></a>2.5 自定义标签</h3><p>简化代码，替代java代码块。</p>
<h4 id="2-5-1-基本用法"><a href="#2-5-1-基本用法" class="headerlink" title="2.5.1 基本用法"></a>2.5.1 基本用法</h4><p>（1）、需求</p>
<p>自定义标签，输出客户端Ip</p>
<p>（2）、定义标签处理器</p>
<p>实现处理器接口：javax.servlet.jsp.tagext.simpleTag</p>
<pre><code>//定义标签处理器
public class ClientIpTag extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        //获取pageContext
        PageContext pc = (PageContext) this.getJspContext();
        //获取请求对象
        ServletRequest request = pc.getRequest();
        //获取客户端IP
        String clientIp = request.getRemoteAddr();
        //获取标准输出流
        JspWriter out = pc.getOut();
        //输出
        out.print(clientIp);
    }
}
</code></pre><p>（3）、注册标签处理器</p>
<p>//customTags.tld</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;
    version=&quot;2.0&quot;&gt;
    &lt;!--配置标签库信息--&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;short-name&gt;customTags&lt;/short-name&gt;
    &lt;uri&gt;http://www.jstlproject.com/jsp/tags/custom&lt;/uri&gt;
    &lt;!--注册标签--&gt;
    &lt;tag&gt;
        &lt;name&gt;clientIp&lt;/name&gt;
        &lt;tag-class&gt;tags.ClientIpTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;/tag&gt;

&lt;/taglib&gt;
</code></pre><p>（4）、使用自定义标签</p>
<pre><code>&lt;%@ taglib uri = &quot;http://www.jstlproject.com/jsp/tags/custom&quot; prefix = &quot;customTags&quot; %&gt;
&lt;body&gt;
    &lt;% 
        String ip = request.getRemoteAddr();
        out.println(&quot;ip = &quot; + ip);
    %&gt;
    &lt;br/&gt;
    &lt;customTags:clientIp /&gt;
&lt;/body&gt;
</code></pre><h4 id="2-5-2-定义带标签体的标签"><a href="#2-5-2-定义带标签体的标签" class="headerlink" title="2.5.2 定义带标签体的标签"></a>2.5.2 定义带标签体的标签</h4><p>//标签处理器 - 小写变大写</p>
<pre><code>public class LowerToUpperTag extends SimpleTagSupport {
    @Override
    public void doTag() throws JspException, IOException {
        //获取标签体对象
        JspFragment jspbody = this.getJspBody();
        //创建字符串输出流
        StringWriter strWriter = new StringWriter();
        //标签体对象写入字符串输出流
        jspbody.invoke(strWriter);
        //字符串输出流中的数据
        String str = strWriter.toString();
        //小写变大写
        str = str.toUpperCase();
        //写入标准输出流
        this.getJspContext().getOut().print(str);
    }
}
</code></pre><p>注册</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;
    version=&quot;2.0&quot;&gt;
    &lt;!--配置标签库信息--&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;short-name&gt;customTags&lt;/short-name&gt;
    &lt;uri&gt;http://www.jstlproject.com/jsp/tags/custom&lt;/uri&gt;
    &lt;!--注册标签--&gt;
    &lt;tag&gt;
        &lt;name&gt;clientIp&lt;/name&gt;
        &lt;tag-class&gt;tags.ClientIpTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
    &lt;/tag&gt;
    &lt;tag&gt;
        &lt;name&gt;lowerToUpper&lt;/name&gt;
        &lt;tag-class&gt;tags.LowerToUpperTag&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;
    &lt;/tag&gt;

&lt;/taglib&gt;
</code></pre><p>附：<body-content></body-content></p>
<ul>
<li>empty:表示当前标签没有标签体</li>
<li>scriptless：表示当前标签具有标签体，对el表达式解析。</li>
<li>jsp:原样输出，已过时</li>
<li>tagdependent: 原样输出到浏览器，不解析el表达式</li>
</ul>
<p>//index.jsp</p>
<pre><code>&lt;%@ taglib uri = &quot;http://www.jstlproject.com/jsp/tags/custom&quot; prefix = &quot;customTags&quot; %&gt;

&lt;body&gt;

    &lt;%
        String username = &quot;aaa&quot;;
        pageContext.setAttribute(&quot;username&quot;, username);
    %&gt;
    &lt;customTags:lowerToUpper&gt;${username }&lt;/customTags:lowerToUpper&gt;

&lt;/body&gt;
</code></pre><h4 id="2-5-3-定义带属性的标签"><a href="#2-5-3-定义带属性的标签" class="headerlink" title="2.5.3 定义带属性的标签"></a>2.5.3 定义带属性的标签</h4><p>//注册标签</p>
<pre><code>&lt;tag&gt;
    &lt;name&gt;if&lt;/name&gt;
    &lt;tag-class&gt;tags.IfTag&lt;/tag-class&gt;
    &lt;body-content&gt;tagdependent&lt;/body-content&gt;
        &lt;attribute&gt;
            &lt;name&gt;test&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;!-- runtime expression value 
                true:该属性的值支持el表达式与jsp表达式
            --&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
&lt;/tag&gt;
</code></pre><p>//定义标签处理器</p>
<pre><code>public class IfTag extends SimpleTagSupport {
    private boolean test;
    //标签的属性反映到标签处理器中，就是一个set属性
    public void setTest(boolean test) {
        this.test = test;
    }
    @Override
    public void doTag() throws JspException, IOException {
        if(test) {
            /*
            JspFragment jspbody = this.getJspBody();
            jspbody.invoke(this.getJspContext().getOut());
            */
            //以上代码等价于以下代码
            this.getJspBody().invoke(null);
        }
    }
}
</code></pre><p>//index.jsp</p>
<pre><code>&lt;customTages:if test = ${gender} }} }&gt;男&lt;/customTages:if&gt;
&lt;customTages:if test = not gender }&gt;女&lt;/customTages:if&gt;
</code></pre><h4 id="2-5-4-定义forEach标签"><a href="#2-5-4-定义forEach标签" class="headerlink" title="2.5.4 定义forEach标签"></a>2.5.4 定义forEach标签</h4><p>//定义标签处理器，遍历collection集合和数组</p>
<pre><code>public class ForEachTag extends SimpleTagSupport {

    private Object items;
    private String var;

    public void setItems(Object items) {
        this.items = items;
    }    

    public void setVar(String var) {
        this.var = var;
    }

    public Collection getcoll() {
        if(items instanceof List) {
            return (List) items;
        }else if(items instanceof Set) {
            return (Set) items;
        }else if(items instanceof Map) {
            return ((Map) items).entrySet();
        }else if(items instanceof Object[]) {
            return Arrays.asList((Object[])items);
        }
        return null;
    }

    @Override
    public void doTag() throws JspException, IOException {
        for (Object obj:getcoll()) {
            this.getJspContext().setAttribute(var, obj);
            this.getJspBody().invoke(null);
        }
    }

}
</code></pre><p>//注册</p>
<pre><code> &lt;tag&gt;
    &lt;name&gt;forEach&lt;/name&gt;
    &lt;tag-class&gt;tags.ForEachTag&lt;/tag-class&gt;
    &lt;body-content&gt;scriptless&lt;/body-content&gt;
        &lt;attribute&gt;
            &lt;name&gt;items&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
        &lt;attribute&gt;
            &lt;name&gt;var&lt;/name&gt;
            &lt;required&gt;true&lt;/required&gt;
            &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
&lt;/tag&gt;
</code></pre><p>//index.jsp</p>
<pre><code>&lt;customTags:forEach items=&quot;${citys}&quot; var=&quot;city&quot;&gt;
    ${city }&lt;br&gt;
&lt;/customTags:forEach&gt;
</code></pre><h4 id="2-5-5-将自定义标签库打包发行"><a href="#2-5-5-将自定义标签库打包发行" class="headerlink" title="2.5.5 将自定义标签库打包发行"></a>2.5.5 将自定义标签库打包发行</h4><p>1、右键export选择jar包，只打包源码。</p>
<p>2、把.tld注册文件，放到jar包里的META-INFO里面。</p>
<p>3、把jar包放到项目的WEB-INF的lib下。</p>
<p>4、jsp页面中导入标签库，就可以直接用了。</p>
<h3 id="2-6-JSTL"><a href="#2-6-JSTL" class="headerlink" title="2.6 JSTL"></a>2.6 JSTL</h3><p>jsp standard tag library，包含五个子库。</p>
<p>核心标签库、格式化标签库、EL函数标签库、SQL操作标签库（过时）、XML操作标签库（过时）。</p>
<p>导入jstl.jar包和standard.jar包</p>
<h4 id="2-6-1-核心标签库"><a href="#2-6-1-核心标签库" class="headerlink" title="2.6.1 核心标签库"></a>2.6.1 核心标签库</h4><p>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a>“ prefix=”c” %&gt;</p>
<p>（1）、c:set</p>
<pre><code>//将变量存放到指定域中
&lt;c:set var=&quot;name&quot; value=&quot;zhangsan&quot; scope=&quot;session&quot;&gt;
name = ${sessionScope.name}

//为Bean的属性赋值
&lt;%
    Student student = new Student();
    pageContext.setAttribute(&quot;student&quot;, student);
%&gt;
&lt;c:set value=&quot;lisi&quot; property=&quot;name&quot; target=&quot;${pageScope.student}&quot;&gt;&lt;/c:set&gt;
student = ${student}

//为map赋值
&lt;%
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    pageContext.setAttribute(&quot;map&quot;, map);
%&gt;
&lt;c:set value=&quot;abc&quot; property=&quot;company&quot; target=&quot;${pageScope.map}&quot;&gt;&lt;/c:set&gt;
map = ${map}
</code></pre><p>（2）、c:remove</p>
<pre><code>//从域属性空间中删除变量
&lt;c:remove var=&quot;school&quot;&gt;
</code></pre><p>（3）、c:out</p>
<pre><code>//输出指定的变量
&lt;c:set var=&quot;city&quot; value=&quot;&lt;h1&gt;beijing&lt;/h1&gt;&quot;&gt;

city1 = &lt;c:out value=&quot;${city}&quot;/&gt;

&lt;br /&gt;

city2 = &lt;c:out value=&quot;${city}&quot; escapeXml=&quot;false&quot; /&gt;

city1对h1标签进行了解析。

city2对h1标签没有进行解析，直接输出。
</code></pre><p>（4）、c:catch</p>
<pre><code>//获取异常信息
&lt;c:catch var=&quot;ex&quot;&gt;
    &lt;%
        int i = 3/0;
    %&gt;
&lt;/c:catch&gt;
</code></pre><p>（5）、c:if</p>
<pre><code>&lt;c:if test=&quot;${user == &quot;zhangsan&quot;}&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;进入系统&lt;/a&gt;
&lt;/c:if&gt;
</code></pre><p>（6）、c:choose</p>
<pre><code>&lt;c:choose&gt;
    &lt;c:when test=&quot;${pagenumber == 1}&quot;&gt;
        第一页
    &lt;/c:when&gt;
    &lt;c:when test=&quot;${pagenumber == 2}&quot;&gt;
        第二页
    &lt;/c:when&gt;
    &lt;c:otherwise&gt;
        第三页
    &lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre><p>（7）、c:forEach</p>
<pre><code>//遍历集合
&lt;c:forEach items=&quot;${citys}&quot; var=&quot;city&quot; begin=&quot;0&quot; end=&quot;7&quot; step=&quot;4&quot;&gt;
    ${city} &lt;br&gt;
&lt;/c:forEach&gt;

//输出行号
&lt;c:forEach items=&quot;${students}&quot; var=&quot;student&quot; varStatus=&quot;vs&quot;&gt;
    &lt;tr class=&quot;${vs.count/2 == 0 ? &apos;even&apos; : &apos;odd&apos;}&quot;&gt;
        &lt;td&gt;${vs.count}&lt;/td&gt;
        &lt;td&gt;${student.name}&lt;/td&gt;
        &lt;td&gt;${student.age}&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre><h4 id="2-6-1-格式化标签库"><a href="#2-6-1-格式化标签库" class="headerlink" title="2.6.1 格式化标签库"></a>2.6.1 格式化标签库</h4><p>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank" rel="external">http://java.sun.com/jsp/jstl/fmt</a>“ prefix=”fmt” %&gt;</p>
<pre><code>&lt;%
    Date now = new Date();
    pageContext.setAttribute(&quot;now&quot;, now);
%&gt;

//格式化日期，输出到浏览器
now = &lt;fmt:formatDate value=&quot;${now}&quot; pattern=&quot;yyyy-MM-dd&quot;&gt;

//格式化日期，将结果放到域中的变量里
&lt;fmt:formatDate value=&quot;${now}&quot; pattern=&quot;yyyy-MM-dd&quot; var=&quot;birth&quot;&gt;
生日：&lt;input type=&quot;text&quot; name=&quot;birthday&quot; value=&quot;${birth}&quot; /&gt;
</code></pre><h4 id="2-6-2-jstl下载"><a href="#2-6-2-jstl下载" class="headerlink" title="2.6.2 jstl下载"></a>2.6.2 jstl下载</h4><p>apache.org –&gt; Tomcat –&gt; Taglibs –&gt; Download</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/31/java/java-jsp/java-jsp-2/" data-id="cji15cnsu003zu0fy8lewk2xj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-jsp/java-jsp-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/java/java-jsp/java-jsp-1/" class="article-date">
  <time datetime="2018-01-31T11:27:10.000Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/java/java-jsp/java-jsp-1/">第1章 JSP基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第1章-JSP基础"><a href="#第1章-JSP基础" class="headerlink" title="第1章 JSP基础"></a>第1章 JSP基础</h3><h4 id="1-1-JSP"><a href="#1-1-JSP" class="headerlink" title="1.1 JSP"></a>1.1 JSP</h4><p>JSP文件的本质是Servlet。只不过，JSP与Servlet不同的是，JSP是专门用于进行数据展示的Servlet，其有特殊的写法。而普通的Servlet是用于完成业务逻辑处理的。由于Servlet是运行在单例多线程环境下的，所以JSP同样也是运行在单例多线程环境下的。</p>
<h4 id="1-2-JSP规范"><a href="#1-2-JSP规范" class="headerlink" title="1.2 JSP规范"></a>1.2 JSP规范</h4><p>将JSP页面翻译为Servlet的过程，是由Tomcat完成的。在Tomcat中内置了一个JSP的翻译引擎，当第一次访问该JSP页面时，翻译引擎会将JSP页面翻译为Servlet的.java文件，再将其编译为.class文件进行运行。</p>
<p>SUN公司制定的JavaEE规范中包含两个很重要的子规范，Servlet规范和JSP规范。其中，JSP规范中就包含了如何将JSP页面翻译为Servlet。例如，JSP页面中的html、css、javascript、普通文件部分，均会被翻译到out.write()中。</p>
<h4 id="1-3-JSP注释"><a href="#1-3-JSP注释" class="headerlink" title="1.3 JSP注释"></a>1.3 JSP注释</h4><p>JSP注释：<code>&lt;%-- --%&gt;</code></p>
<p>HTML注释：<code>&lt;!-- --&gt;</code></p>
<p>JSP注释与HTML注释区别：</p>
<p>（1）、HTML注释会被JSP翻译引擎翻译到Servlet的out.write()中；而JSP注释会被翻译引擎忽略，在Servlet中看不到。</p>
<p>（2）、客户端浏览器查看源码时，HTML注释是可以查看到的；JSP注释查看不到。</p>
<h4 id="1-4-JSP的java代码块"><a href="#1-4-JSP的java代码块" class="headerlink" title="1.4 JSP的java代码块"></a>1.4 JSP的java代码块</h4><p><code>&lt;% %&gt;</code> java代码块出现在Servlet的_jspService()方法中，不能定义方法，不能定义静态语句块。</p>
<pre><code>&lt;html&gt;
    &lt;% double b = 2; %&gt;
    &lt;body&gt;
        &lt;% int a = 1; %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="1-5-JSP的声明语句块"><a href="#1-5-JSP的声明语句块" class="headerlink" title="1.5 JSP的声明语句块"></a>1.5 JSP的声明语句块</h4><p><code>&lt;%!  %&gt;</code> 声明语句块中的内容，将出现在Servlet类体中，没有包含到哪个方法体中。有线程安全隐患</p>
<pre><code>&lt;%! 
    private int amount = 3;

    public void showData(){
        syso(&quot;aaaaa&quot;);
    }
 %&gt;
</code></pre><h4 id="1-6-JSP的表达式块"><a href="#1-6-JSP的表达式块" class="headerlink" title="1.6 JSP的表达式块"></a>1.6 JSP的表达式块</h4><p><code>&lt;%= %&gt;</code> 表达式块出现的_jspService()方法的out.write()方法中。</p>
<pre><code>count = &lt;%=count %&gt;

//Servlet
out.write(&quot;count = &quot;);
out.write(count);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/31/java/java-jsp/java-jsp-1/" data-id="cji15cnsr003wu0fyhihq37oo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp/">jsp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/java-servlet/java-servlet-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/java/java-servlet/java-servlet-2/" class="article-date">
  <time datetime="2018-01-25T12:30:10.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/java/java-servlet/java-servlet-2/">java Servlet 二、核心</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="二、Servlet核心"><a href="#二、Servlet核心" class="headerlink" title="二、Servlet核心"></a>二、Servlet核心</h3><h4 id="2-1-GenericServlet"><a href="#2-1-GenericServlet" class="headerlink" title="2.1 GenericServlet"></a>2.1 GenericServlet</h4><h4 id="2-1-1-GenericServlet-源码"><a href="#2-1-1-GenericServlet-源码" class="headerlink" title="2.1.1 GenericServlet 源码"></a>2.1.1 GenericServlet 源码</h4><pre><code>//缺省适配器设计模式
public abstract class GenericServlet implements Servlet, ServletConfig,
        java.io.Serializable {

    private transient ServletConfig config;

    @Override
    public void destroy() {
        // NOOP by default
    }

    @Override
    public String getInitParameter(String name) {
        return getServletConfig().getInitParameter(name);
    }

    @Override
    public Enumeration&lt;String&gt; getInitParameterNames() {
        return getServletConfig().getInitParameterNames();
    }

    @Override
    public ServletConfig getServletConfig() {
        return config;
    }


    @Override
    public ServletContext getServletContext() {
        return getServletConfig().getServletContext();
    }


    @Override
    public String getServletInfo() {
        return &quot;&quot;;
    }

    //模板设计模式
    public void init(ServletConfig config) throws ServletException {
        this.config = config;
        //调用无参的init()方法
        this.init();
    }

       //该无参的init()方法，就是要让子类来重写的
    public void init() throws ServletException {
        // NOOP by default
    }

    //抽象化service方法，让子类去实现
    public abstract void service(ServletRequest req, ServletResponse res)
            throws ServletException, IOException;


    @Override
    public String getServletName() {
        return config.getServletName();
    }
}
</code></pre><p>实现了servlet接口，并抽象化了service方法，让子类去实现。</p>
<p>实现了servletconfig接口，子类可以直接调用servletconfig的方法。</p>
<h4 id="2-1-2-获取请求的提交方式"><a href="#2-1-2-获取请求的提交方式" class="headerlink" title="2.1.2 获取请求的提交方式"></a>2.1.2 获取请求的提交方式</h4><pre><code>public class genericSevletDemo extends GenericServlet {
    private static final long serialVersionUID = 1L;

    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse) response;
        String method = req.getMethod();

        if(&quot;POSt&quot;.equals(method)){
            doPost(req,res);
        }else if(&quot;GET&quot;.equals(method)){
            doGet(req,res);
        }
    }

}
</code></pre><p>继续封装doPost和doGet为HttpServlet类</p>
<h4 id="2-2-HttpServlet"><a href="#2-2-HttpServlet" class="headerlink" title="2.2 HttpServlet"></a>2.2 HttpServlet</h4><p>HttpServlet源码</p>
<pre><code>public abstract class HttpServlet extends GenericServlet {

    @Override
public void service(ServletRequest req, ServletResponse res){
     HttpServletRequest  request;
    HttpServletResponse response;

    try {
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;
    } catch (ClassCastException e) {
        throw new ServletException(&quot;non-HTTP request or response&quot;);
    }
    service(request, response);
}

     protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
            ...
        }

    protected void doPost(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        ...
        }
} 
</code></pre><p>//servlet继承httpservlet类</p>
<pre><code>public class HttpservDemo extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h4 id="2-3-HttpServletRequest"><a href="#2-3-HttpServletRequest" class="headerlink" title="2.3 HttpServletRequest"></a>2.3 HttpServletRequest</h4><h5 id="2-3-1-请求的生命周期"><a href="#2-3-1-请求的生命周期" class="headerlink" title="2.3.1 请求的生命周期"></a>2.3.1 请求的生命周期</h5><p>当客户端浏览器将请求发送到服务器后，服务器会根据HTTP请求协议的格式对请求进行解析。同时，服务器会创建HttpServletRequest的实现类RequestFacade的对象，即请求对象。然后再调用相应的set方法，将解析出的数据封装到请示对象中。此时HttpServletRequest实例就创建并初始化完成了。也就是说，请求对象是由服务器创建的的。</p>
<p>当服务器向客户端发送响应结束后，HttpServletRequest实例对象就被服务器销毁。</p>
<p>一次请求对应一个请求对象，别外一次请求对应另一个请求对象，与之前的请求对象没有任何关系。HttpServletRequest实例的生命周期很短暂。</p>
<h5 id="2-3-2-请求参数"><a href="#2-3-2-请求参数" class="headerlink" title="2.3.2 请求参数"></a>2.3.2 请求参数</h5><p>HttpServletRequest对于请求中所携带的参数是以Map的形式接收的，并且该Map的key为String，value为String数组（一个请求参数可能会有多个值的情况出现）。</p>
<pre><code>public class HttpservDemo extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //getParameter()方法，获取指定key对应的value，等同于getParameterValues()[0]
        String name = request.getParameter(&quot;name&quot;);
        String ageStr = request.getParameter(&quot;age&quot;);
        Integer age = Integer.valueOf(ageStr);
        System.out.println(&quot;name = &quot;+name);
        System.out.println(&quot;age = &quot;+age);

        //getParameterName()方法,获取所有keys
        Enumeration&lt;String&gt; names = request.getParameterNames();
        while(names.hasMoreElements()) {
            String eleName = names.nextElement();
            String eleValue = request.getParameter(eleName);
            System.out.println(eleName + &quot;-----&quot; + eleValue);
        }

        //getParameterValues()方法,获取指定key对应的所有values，
        //如&lt;checkbox name = &quot;hobby&quot;&gt;running&lt;/checkbox&gt;
        //如&lt;checkbox name = &quot;hobby&quot;&gt;reading&lt;/checkbox&gt;
        String[] hobby = request.getParameterValues(&quot;hobby&quot;);
        for(String h : hobby) {
            System.out.println(h);
        }

        //getParameterMap()方法,获取存放请求参数的Map
        Map&lt;String, String[]&gt; map = request.getParameterMap();
        for(String key : map.keySet()) {
            System.out.println(key+&quot;-----&quot;+request.getParameter(key));
        }
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

}
</code></pre><h5 id="2-3-3-域属性"><a href="#2-3-3-域属性" class="headerlink" title="2.3.3 域属性"></a>2.3.3 域属性</h5><p>Request中也存在域属性空间，用于存放有名称的数据。该数据只在当前Request请求中可以访问。</p>
<p>对于Request中的域属性操作的常用方法：</p>
<p>设置</p>
<pre><code>void setAttribute(String name, Object object);
</code></pre><p>获取</p>
<pre><code>Object getAttribute(String name);
</code></pre><p>在FirstServlet中设置，跳转到otherServlet中获取</p>
<pre><code>public class FirstServlet extends HttpServlet {   
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setAttribute(&quot;address&quot;, &quot;zhuhaijinwan&quot;);
        request.setAttribute(&quot;phone&quot;, &quot;15011112222&quot;);

        request.getRequestDispatcher(&quot;/other&quot;).forward(request, response);
    }
}

public class OtherServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String address = (String) request.getAttribute(&quot;address&quot;);
        String phone = (String) request.getAttribute(&quot;phone&quot;);

        Enumeration&lt;String&gt; names = request.getAttributeNames();
        while(names.hasMoreElements()) {
            String name = names.nextElement();
            String value = (String) request.getAttribute(name);
        }
    }
}
</code></pre><h5 id="2-3-4-服务器相关信息"><a href="#2-3-4-服务器相关信息" class="headerlink" title="2.3.4 服务器相关信息"></a>2.3.4 服务器相关信息</h5><p>1、获取请求的URL，如：“<a href="http://localhost:8080/httpServlet/some”" target="_blank" rel="external">http://localhost:8080/httpServlet/some”</a></p>
<pre><code>StringBuffer getRequestURL();
</code></pre><p>2、获取请求的URI，如：”/httpServlet/some”</p>
<pre><code>String getRequestURI();
</code></pre><p>3、获取当前应用在Web容器中的名称，如：”httpServlet”</p>
<pre><code>String getContext();    
</code></pre><p>4、获取路径中与web.xml中注册servlet时的<code>&lt;url-pattern/&gt;</code>相匹配的路径信息</p>
<pre><code>//servletPath指的是与&lt;url-pattern&gt;精确部分相匹配的路径
String getServletPath()

//pathInfo指的是与非精确部分相匹配的路径
String getPathInfo()
</code></pre><p>a、例如:<code>&lt;url-pattern/&gt;</code>的值为/xxx/ooo/*，用户提交的请求为：<a href="http://localhost:8080/httpServlet/xxx/ooo/abc/def。" target="_blank" rel="external">http://localhost:8080/httpServlet/xxx/ooo/abc/def。</a></p>
<p>servletPath就是：/xxx/ooo</p>
<p>pathInfo就是：/abc/def</p>
<p>b、若用户提交的请求为后辍方式，如:<a href="http://localhost:8080/httpServlet/aaa/bbb/ccc.do。" target="_blank" rel="external">http://localhost:8080/httpServlet/aaa/bbb/ccc.do。</a></p>
<p>servletpath就是：/aaa/bbb/ccc.do</p>
<p>pathInfo: null</p>
<p>c、URI = ServletContext + ServletPath + PathInfo</p>
<p>5、获取请求的方式是post还是get等</p>
<pre><code>String getMethod()
</code></pre><p>6、获取客户端浏览器的IP</p>
<pre><code>//对于服务器端来说，客户端就是远程端
String getRemoteAddr()
</code></pre><h4 id="2-4-中文乱码问题"><a href="#2-4-中文乱码问题" class="headerlink" title="2.4 中文乱码问题"></a>2.4 中文乱码问题</h4><p>当页面中提交一个包含中文的请求时，在服务器端有可能会出现中文乱码问题。</p>
<h5 id="2-4-1-乱码产生的原因"><a href="#2-4-1-乱码产生的原因" class="headerlink" title="2.4.1 乱码产生的原因"></a>2.4.1 乱码产生的原因</h5><p>Http协议中规定，数据传输采用字节码编码方式，即无论浏览器提交的数据包含的中文是什么字符编码格式，一旦由浏览器经过Http传输协议传输，则这些数据均将以字节码的形式上传给服务器。</p>
<p>因为Http协议的底层使用的TCP（Transmission Contrl Protocol）传输协议。传输控制协议是一种面向连接的、可靠的、基于字节流的、端对端的通信协议。在请求中，这些字节均以%开头，并以十六进制形式出现。如%5A%3D等。</p>
<p>那么乱码是如何产生的呢？</p>
<p>当用户通过浏览器提交一个包含 UTF-8编码格式的两个字的中文请求时，浏览器会将这两个中文字符变为六个字节，即形成六个类似%8E的字节表示形式，并将这六个字节上传到tomcat服务器。</p>
<p>tomcat服务器接收到这六个字节后，并不知道它们原来采用的是什么字符编码。而tomcat默认的编码格式为ISO-8859-1。所以会将这个六个字符按照这种格式进行编码，编码后在控制台显示，所以在控制台会显示乱码。</p>
<h5 id="2-4-3-乱码的解决方法"><a href="#2-4-3-乱码的解决方法" class="headerlink" title="2.4.3 乱码的解决方法"></a>2.4.3 乱码的解决方法</h5><p>1、tomcat9已经解决了GET提交时的中文乱码问题。</p>
<p>2、request.setCharacterEncoding(“UTF-8”);解决了POST提交中文时的乱码问题。无法解决GET提交时的中文乱码问题。</p>
<p>3、Get提交时中文乱码解决方案有两种：</p>
<p>（1）、修改tomcat/conf/server.xml，添加URIEncoding</p>
<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
    connectionTimeOut=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;
/&gt;
</code></pre><p>(2)、无论Post还是get都可以</p>
<pre><code>String name = request.getParaeter(&quot;name&quot;);
byte[] bytes = name.getBytes(&quot;ISO8859-1&quot;);
name = new String(bytes,&quot;UTF-8&quot;);
</code></pre><h4 id="2-5-HttpServletResponse"><a href="#2-5-HttpServletResponse" class="headerlink" title="2.5 HttpServletResponse"></a>2.5 HttpServletResponse</h4><p>web服务器收到一个Http请求后，会针对每个请求创建一个HttpServletRequest对象和HttpServletResponse对象。若需要获取客户端提交请求的相关信息，刚需要HttpServletRequest对象来完成。若需要向客户端发送数据，则需要通过HttpServletResponse对象来完成。</p>
<h5 id="2-5-1-向客户端发送数据"><a href="#2-5-1-向客户端发送数据" class="headerlink" title="2.5.1 向客户端发送数据"></a>2.5.1 向客户端发送数据</h5><p>ServletResonse接口有一个方法getWriter()，用于获取到一个输出流对象PrintWriter，该输出流对象是专门用于向客户端浏览器中输出字符数据的，称为标准输出流。</p>
<pre><code>response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());

PrintWriter out = response.getWriter();
out.append(&quot;dddd&quot;);
out.print(&quot;aaa&quot;);
out.pirntln(&quot;bbbb&quot;);
out.Write(&quot;ccc&quot;);
</code></pre><h5 id="2-5-2-响应乱码的产生"><a href="#2-5-2-响应乱码的产生" class="headerlink" title="2.5.2 响应乱码的产生"></a>2.5.2 响应乱码的产生</h5><p>两种方法：</p>
<p>1、设置MIME类型，设置字符编码格式</p>
<pre><code>response.setContentType(&quot;text/html&quot;);
response.setCharacterEncoding(&quot;UTF-8&quot;);
</code></pre><p>2、同时设置MIME类型和字符编码格式</p>
<pre><code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);
</code></pre><h4 id="2-6-请求转发与重定向"><a href="#2-6-请求转发与重定向" class="headerlink" title="2.6 请求转发与重定向"></a>2.6 请求转发与重定向</h4><p>通过HttpServletRequest获取到的RequestDispatcher对象的forward()方法，可以完成请求转发功能。</p>
<p>而通过HttpServletResponse的sendRedirect()方法，可以完成重定向功能。</p>
<h5 id="2-6-1什么是请求转发与重定向"><a href="#2-6-1什么是请求转发与重定向" class="headerlink" title="2.6.1什么是请求转发与重定向"></a>2.6.1什么是请求转发与重定向</h5><p>请求转发：一次请求，一次响应。</p>
<p>重定向：多次请求，多次响应。</p>
<h5 id="2-6-2-请求转发程序举例"><a href="#2-6-2-请求转发程序举例" class="headerlink" title="2.6.2 请求转发程序举例"></a>2.6.2 请求转发程序举例</h5><pre><code>public class SomServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter(&quot;name&quot;);
        String age = req.getParameter(&quot;age&quot;);
        req.setAttribute(&quot;ageStr&quot;, age);
        //请求转发
        req.getRequestDispatcher(&quot;other&quot;).forward(req, resp);
    }
}

public class OtherServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //可以继续使用request,response,也可以获取someServlet中设置的域属性
        String name = request.getParameter(&quot;name&quot;);
        request.getAttribute(&quot;ageStr&quot;);

        PrintWriter out = response.getWriter();
        out.print(&quot;this is otherServlet&quot;);
    }
}
</code></pre><h5 id="2-6-3-重定向举例"><a href="#2-6-3-重定向举例" class="headerlink" title="2.6.3 重定向举例"></a>2.6.3 重定向举例</h5><pre><code>public class SomServlet extends HttpServlet {

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter(&quot;name&quot;);
        String age = req.getParameter(&quot;age&quot;);
        req.setAttribute(&quot;ageStr&quot;, age);
        req.getRequestDispatcher(&quot;other&quot;).forward(req, resp);

        //重定向
        resp.sendRedirect(&quot;other&quot;);
    }
}

public class OtherServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //不能再继续使用request,response,也不能获取someServlet中设置的域属性
        PrintWriter out = response.getWriter();
        out.print(&quot;this is otherServlet&quot;);
    }

}
</code></pre><h5 id="2-6-4-重定向时的数据传递"><a href="#2-6-4-重定向时的数据传递" class="headerlink" title="2.6.4 重定向时的数据传递"></a>2.6.4 重定向时的数据传递</h5><p>//重定向数据传递，及乱码解决方案</p>
<pre><code>public class SomServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter(&quot;name&quot;);
        //解决中文乱码
        name = new String(name.getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;);

        String age = req.getParameter(&quot;age&quot;);
        req.setAttribute(&quot;ageStr&quot;, age);
        req.getRequestDispatcher(&quot;other&quot;).forward(req, resp);

        //编码，解决重定向传递时乱码问题
        name =  URLEncoder.encode(name,&quot;UTF-8&quot;);

        //重定向
        resp.sendRedirect(&quot;other?pname=&quot;+name+&quot;&amp;page=&quot;+age);
    }

}    

public class OtherServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        String pname = request.getParameter(&quot;pname&quot;);
        //解码
        pname = URLDecoder.decode(pname,&quot;UTF-8&quot;);

        //打散组装
        pname = new String(pname.getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;);

        String page = request.getParameter(&quot;page&quot;);

        System.out.println(&quot;pname====&quot; +pname);
        System.out.println(&quot;page====&quot; +page);

        PrintWriter out = response.getWriter();
        out.print(&quot;this is otherServlet&quot;);
    }

}
</code></pre><h5 id="2-6-5-重定向到其它应用"><a href="#2-6-5-重定向到其它应用" class="headerlink" title="2.6.5 重定向到其它应用"></a>2.6.5 重定向到其它应用</h5><p>重定向与请求转发还有一点很重要的不同点是，重定向可以跳转到其它应用中，而请求转发只能在当前应用中跳转。也正因为如此，所以sendRedirect()的参数中，必须要添加request.getContext(),即当前应用的根目录，指定要跳转到哪个应用的哪个资源。</p>
<pre><code>//重定向到另一个应用的名称为other的servlet
response.sendRedirect(&quot;/redirect-two/other&quot;);
</code></pre><h5 id="2-6-6-请求转发与重定向对比"><a href="#2-6-6-请求转发与重定向对比" class="headerlink" title="2.6.6 请求转发与重定向对比"></a>2.6.6 请求转发与重定向对比</h5><p>(1)、请求转发</p>
<p>A、浏览器只发出一次请求，收到一次响应</p>
<p>B、请求所转发到的资源中可以直接获取到请求中所携带的数据</p>
<p>C、浏览器地址栏显示的是用户所提交的路径</p>
<p>D、只能跳转到当前应用中的资源</p>
<p>(2)、</p>
<p>A、浏览器发出两次请求，接收到两次响应</p>
<p>B、重定向到的资源不能直接获取到用户提交请求中所携带的数据</p>
<p>C、浏览器地址栏显示的是重定向的请求路径，而非用户提交请求的路径。也正因为如此，重定向有一个很重要的作用：防止表单重复提交</p>
<p>D、重定向不仅可以跳转到当前应用的其它资源，也可以跳转到其它应用中的资源</p>
<h5 id="2-6-7-请求转发与重定向的选择"><a href="#2-6-7-请求转发与重定向的选择" class="headerlink" title="2.6.7 请求转发与重定向的选择"></a>2.6.7 请求转发与重定向的选择</h5><p>（1）、若需跳转到其它应用，只能选择重定向</p>
<p>（2）、若是处理表单数据的servlet，要跳转到其它servlet，则需要选择重定向。为了防止表单重复提交。</p>
<p>（3）、若对某一请求进行处理的servlet的执行需要消耗大量的服务器资源（cpu,内存），此时这个servlet执行完毕后，也需要重定向。</p>
<p>（4）、其它情况，一般使用请求转发。</p>
<h4 id="2-7-RequestDispatcher"><a href="#2-7-RequestDispatcher" class="headerlink" title="2.7 RequestDispatcher"></a>2.7 RequestDispatcher</h4><p>RequestDispatcher是javax.servlet包下的一个接口，通过HttpServletRequest可以获取到其接口对象，该对象就是用于完成转发功能的。</p>
<h4 id="2-7-1-forward-与include"><a href="#2-7-1-forward-与include" class="headerlink" title="2.7.1 forward()与include()"></a>2.7.1 forward()与include()</h4><p>SomeServlet</p>
<pre><code>public class SomServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;some request = &quot; + req);
        System.out.println(&quot;some resp = &quot; + resp);
        req.getRequestDispatcher(&quot;other&quot;).forward(req, resp);
    }

}
</code></pre><p>OtherServlet</p>
<pre><code>public class OtherServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println(&quot;other response = &quot; + response);
        System.out.println(&quot;other request = &quot; + request);
    }

}
</code></pre><p>输出结果中的request：</p>
<pre><code>some request = org.apache.catalina.connector.RequestFacade@289113c7
other request = org.apache.catalina.core.ApplicationHttpRequest@4d0d88e6
</code></pre><p>1、other中的HttpServletRequest request是对some中的HttpServletRequest req的增强，实际上是将用户请求和转发请求这两次请求进行了合并。</p>
<p>2、将req.getRequestDispatcher(“other”).forward(req, resp);改为req.getRequestDispatcher(“other”).include(req, resp);后，输出结果和上面的相同。说明对于request，forward与include没有区别。</p>
<p>输出结果中的response:</p>
<pre><code>//forward()方法跳转时    
some resp = org.apache.catalina.connector.ResponseFacade@6451e20e
other response = org.apache.catalina.connector.ResponseFacade@6451e20e

//include()方法跳转时
some resp = org.apache.catalina.connector.ResponseFacade@48202e11
other response = org.apache.catalina.core.ApplicationHttpResponse@5f53ab27
</code></pre><p>1、forward()方法跳转时，some中的resp与other中的response一样，都是ResponseFacade。</p>
<p>2、include()方法跳转时，some中的resp为ResponseFacade，other中的response为ApplicationHttpResponse。</p>
<p>3、说明requestDispatcher的forward()与include()的区别，主要集中在响应对象上。</p>
<h4 id="2-7-2-代码测试"><a href="#2-7-2-代码测试" class="headerlink" title="2.7.2 代码测试"></a>2.7.2 代码测试</h4><p>SomeServlet</p>
<pre><code>public class SomServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();
        out.print(&quot;someServlet:forward() before &quot;);

        req.getRequestDispatcher(&quot;other&quot;).forward(req, resp);

        out.print(&quot;someServlet:forward() after &quot;);
    }

}
</code></pre><p>OtherServlet</p>
<pre><code>public class OtherServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        PrintWriter out = response.getWriter();
        out.print(&quot;other servlet data&quot;);
    }

}
</code></pre><p>客户端浏览器输出结果：</p>
<p>forward()方法跳转的输出结果：</p>
<pre><code>other servlet data
</code></pre><p>incluce()方法跳转的输出结果：</p>
<pre><code>someServlet:forward() before 
other servlet data
someServlet:forward() after 
</code></pre><p>1、forward()与include()的区别，主要表现在标准输出流的开启时间不同。</p>
<p>2、说明在SomeServlet中，用forward()方法向前跳转时，请求此时还并没有结束，所以reqp还没有开启，因此两个输出语句没有执行。</p>
<p>3、include()方法跳转时，some和other中的输出语句全部执行。说明，include不仅将other的数据写入到了标准输出流中，也将some中的数据包含到了自己的输出流中，</p>
<p>4、forward的转发示意：</p>
<p>浏览器—&gt;发送请求—&gt;服务器中的SomeServlet—-&gt;发送请求—-&gt;服务器中的OtherServlet—&gt;OtherServlet对浏览器做出响应。</p>
<p>向浏览器给出响应的是OtherServlet，输出流是在OtherServlet中开启的。</p>
<p>5、include的转发示意：</p>
<p>浏览器—&gt;发送请求—&gt;服务器中的SomeServlet—-&gt;发送请求—&gt;服务器中的OtherServlet—-&gt;OtherServlet将SomeServlet进行了包含，并向SomeServlet做出响应 —&gt; SomeServle对浏览器做出响应。</p>
<p>向浏览器给出响应的是SomeServlet，输出流在SomeServlet中就开启了。</p>
<p>包含的过程就是由ApplicationHttpResponse这个增强的response来完成的。</p>
<h3 id="2-9-Servlet的线程安全问题"><a href="#2-9-Servlet的线程安全问题" class="headerlink" title="2.9 Servlet的线程安全问题"></a>2.9 Servlet的线程安全问题</h3><p>Servlet是单例多线程环境下运行的，其运行可能会产生线程安全问题。</p>
<h4 id="2-9-1-线程安全问题"><a href="#2-9-1-线程安全问题" class="headerlink" title="2.9.1 线程安全问题"></a>2.9.1 线程安全问题</h4><p>1、同时满足以下两个条件，则会出现线程安全问题。</p>
<p>（1）、存在多线程并发访问</p>
<p>（2）、存在可修改的共享数据</p>
<p>2、JVM中可能存在线程安全问题的数据分析</p>
<p>（1）、栈内存数据分析</p>
<p>栈内存是是多例的，即JVM会为每个线程创建一个栈，所以其中的数据是不共享的。另外，栈里面放的是方法栈帧，一个方法在栈里面，以一个栈帧的形式出现，方法的栈帧中放的是方法的签名（头部信息）、局部变量、返回的信息等，方法中的局部变量存放在Stack的栈帧中，方法执行完毕，栈帧弹栈，局部变量消失。局部变量是局部的，不是共享的。所以栈内存中的数据不存在线程安全问题。</p>
<p>（2）、堆内存数据分析</p>
<p> 一个JVM中只存放一个堆内存，堆内存是共享的。被创建出的对象存放在堆内存中，而存放在堆内存中的对象，实际就是对象成员变量的集合。即成员变量是存放在堆内存的。堆内存中的数据是多线程共享的，也就是说，堆内存中的数据是存在线程安全隐患的。</p>
<p>（3）、方法区数据分析</p>
<p>一个JVM中只存在一个方法区。方法的代码片段，静态变量与常量都存放在方法区，方法区是多线程共享的。常量是不能修改的，所以常量不存在安全问题。静态变量是多线程共享的，所以静态变量存在安全隐患。 </p>
<p>3、线程安全问题的解决方案</p>
<p>（1）、对于一般性的类，不要定义为单例的。除非项目有特殊需求，或该类对象属于重量级对象。所谓重量级对象是指，创建该类对象是会占用较大的系统资源。</p>
<p>（2）、无论类是否为单例类，尽量不要使用静态变量。</p>
<p>（3）、若需要定义为单例类，则单例类尽量不使用成员变量（例如Servlet类）。</p>
<p>（4）、若单例类中必须要使用成员变量，则对成员变量的操作添加串行化锁synchronized，实现线程同步。不过，最好不要使用线程同步机制，因为一旦操作进入串行化的排队状态，将大大降低程序的执行效率。</p>
<h4 id="2-9-2-Servlet的线程安全问题"><a href="#2-9-2-Servlet的线程安全问题" class="headerlink" title="2.9.2 Servlet的线程安全问题"></a>2.9.2 Servlet的线程安全问题</h4><p>Servlet是单例多线程并发访问的，所以存在线程安全问题。</p>
<p>为了避免问题产生，对用Servlet类的使用，一般是不声明成员变量的。</p>
<p>若项目中必须要求声明成员变量，则只能通过同步机制synchronize避免。</p>
<h4 id="2-9-3-对线程安全问题的合理利用"><a href="#2-9-3-对线程安全问题的合理利用" class="headerlink" title="2.9.3 对线程安全问题的合理利用"></a>2.9.3 对线程安全问题的合理利用</h4><p>Servlet中的成员变量是每一个线程均可修改和访问的，所以可以利用这一点，实现计数器功能，用于统计当前Servlet的被访问的次数。</p>
<pre><code>public class SomeServlet extends HttpServle{
    //定义成员变量 - 计数器
    private int count;
    public void doGet(...){
        count++;
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrinterWriter out = resp.getWriter();
        out.print(&quot;当前网页的访问次数：&quot; + count);

    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/java/java-servlet/java-servlet-2/" data-id="cji15cnt8004gu0fyg0ysh1zx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/servlet/">servlet</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/angularjs/">angularjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">bootstrap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/springmvc/">springmvc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssm/">ssm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collecionsFramework/">collecionsFramework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css-grid/">css-grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsp/">jsp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/regex/">regex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session-cookie/">session cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springmvc/">springmvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssm/">ssm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/足球/">足球</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IO/" style="font-size: 20px;">IO</a> <a href="/tags/angular/" style="font-size: 17.14px;">angular</a> <a href="/tags/api/" style="font-size: 14.29px;">api</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/collecionsFramework/" style="font-size: 15.71px;">collecionsFramework</a> <a href="/tags/css-grid/" style="font-size: 10px;">css-grid</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/jsp/" style="font-size: 12.86px;">jsp</a> <a href="/tags/maven/" style="font-size: 12.86px;">maven</a> <a href="/tags/mybatis/" style="font-size: 17.14px;">mybatis</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/regex/" style="font-size: 10px;">regex</a> <a href="/tags/servlet/" style="font-size: 11.43px;">servlet</a> <a href="/tags/session-cookie/" style="font-size: 10px;">session cookie</a> <a href="/tags/spring/" style="font-size: 18.57px;">spring</a> <a href="/tags/springmvc/" style="font-size: 14.29px;">springmvc</a> <a href="/tags/ssm/" style="font-size: 10px;">ssm</a> <a href="/tags/thread/" style="font-size: 11.43px;">thread</a> <a href="/tags/足球/" style="font-size: 10px;">足球</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/05/java/maven/maven-3/">第三章 maven拆分ssm</a>
          </li>
        
          <li>
            <a href="/2018/06/03/java/maven/maven-2/">第二章 maven整合smm</a>
          </li>
        
          <li>
            <a href="/2018/06/01/java/maven/maven-1/">第一章 maven管理工具</a>
          </li>
        
          <li>
            <a href="/2018/05/26/java/ssm/ssm-1/">第一章 搭建SSM开发环境</a>
          </li>
        
          <li>
            <a href="/2018/05/24/java/springmvc/springmvc-4/">第四章 springmvc核心技术</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>