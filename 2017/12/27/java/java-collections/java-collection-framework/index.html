<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>集合框架一 - Collecion集合 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java集合框架概述">
<meta name="keywords" content="java, api">
<meta property="og:type" content="article">
<meta property="og:title" content="集合框架一 - Collecion集合">
<meta property="og:url" content="http://yoursite.com/2017/12/27/java/java-collections/java-collection-framework/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="java集合框架概述">
<meta property="og:updated_time" content="2018-01-09T06:52:40.495Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="集合框架一 - Collecion集合">
<meta name="twitter:description" content="java集合框架概述">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java/java-collections/java-collection-framework" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/27/java/java-collections/java-collection-framework/" class="article-date">
  <time datetime="2017-12-27T03:35:39.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      集合框架一 - Collecion集合
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="集合框架的构成和分类"><a href="#集合框架的构成和分类" class="headerlink" title="集合框架的构成和分类"></a>集合框架的构成和分类</h3><p>java中集合类的关系图</p>
<p><a href="http://blog.csdn.net/real_neu/article/details/52821491" target="_blank" rel="external">http://blog.csdn.net/real_neu/article/details/52821491</a></p>
<h3 id="一、集合框架-概述"><a href="#一、集合框架-概述" class="headerlink" title="一、集合框架 - 概述"></a>一、集合框架 - 概述</h3><h4 id="1、特点-："><a href="#1、特点-：" class="headerlink" title="1、特点 ："></a>1、特点 ：</h4><ul>
<li><p>用于存储对象的容器。</p>
</li>
<li><p>集合的长度可变。</p>
</li>
<li><p>集合中不能存储基本数据类型值。</p>
</li>
</ul>
<h4 id="2、体系-amp-共性功能"><a href="#2、体系-amp-共性功能" class="headerlink" title="2、体系&amp;共性功能"></a>2、体系&amp;共性功能</h4><p>框架的顶层Collection接口：</p>
<p>1、添加 </p>
<pre><code>boolean add(Object obj)

boolean addAll(Collection coll);
</code></pre><p>2、删除</p>
<pre><code>boolean remove(Object)
boolean removeAll(Collection coll)
void clear()
</code></pre><p>3、判断</p>
<pre><code>boolean contains(Object obj)
boolean containsAll(Collection coll)
boolean isEmpty();
</code></pre><p>4、获取</p>
<pre><code>int size();
Iterator iterator(): 取出元素的方式：迭代器
</code></pre><p>5、其它</p>
<pre><code>boolean retainAll(Collection coll): 取交集
Object toArray(): 将集合转为数组
</code></pre><h4 id="3、方法演示"><a href="#3、方法演示" class="headerlink" title="3、方法演示"></a>3、方法演示</h4><pre><code>import java.util.ArrayList;
import java.util.Collection;

public class CollectionDemo {

    public static void main(String[] args) {
        Collection coll = new ArrayList();
        //show(coll);

        Collection c1 = new ArrayList();
        Collection c2 = new ArrayList();
        show(c1,c2);
    }

    public static void show(Collection c1, Collection c2) {
        //给c1添加元素
        c1.add(&quot;abc1&quot;);
        c1.add(&quot;abc2&quot;);
        c1.add(&quot;abc3&quot;);
        c1.add(&quot;abc4&quot;);

        //给c2添加元素
        c2.add(&quot;abc2&quot;);
        c2.add(&quot;abc6&quot;);
        c2.add(&quot;abc7&quot;);

        System.out.println(&quot;c1:&quot;+c1);
        System.out.println(&quot;c2:&quot;+c2);

        //演示addAll
        c1.addAll(c2);
        System.out.println(&quot;c1:&quot;+c1);

        //演示removeAll，将两个集合中的相同元素从调用removeAll的集合中删除
        //boolean b = c1.removeAll(c2);
        //System.out.println(&quot;removeAll:&quot;+b);
        //System.out.println(&quot;c1:&quot;+c1);

        //演示containsAll
        boolean c = c1.contains(c2);
        System.out.println(&quot;containsAll:&quot;+c);

        //演示retainAll
        System.out.println(&quot;c1:&quot;+c1);
        System.out.println(&quot;c2:&quot;+c2);
        boolean d = c1.retainAll(c2);
        System.out.println(d);
        System.out.println(&quot;c1:&quot;+c1);
    }

    public static void show(Collection coll) {
        //添加
        coll.add(&quot;abc1&quot;);
        coll.add(&quot;abc2&quot;);
        coll.add(&quot;abc3&quot;);
        System.out.println(coll);

        //删除，会改变集合的长度
        coll.remove(&quot;abc2&quot;);
        System.out.println(coll);

        //清空
        coll.clear();
        System.out.println(coll);

        //判断
        System.out.println(coll.contains(&quot;abc3&quot;));
    }

}
</code></pre><h4 id="4、迭代器"><a href="#4、迭代器" class="headerlink" title="4、迭代器"></a>4、迭代器</h4><p>使用方法</p>
<pre><code>import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorDemo {

    public static void main(String[] args) {
        Collection coll = new ArrayList();
        coll.add(&quot;abc1&quot;);
        coll.add(&quot;abc2&quot;);
        coll.add(&quot;abc3&quot;);
        coll.add(&quot;abc4&quot;);
        System.out.println(coll);
        //调用集合中的迭代器方法，是为了获取集合中的迭代器对象
//        Iterator it = coll.iterator();
//        while(it.hasNext()) {
//            System.out.println(it.next());
//        }

        for(Iterator it = coll.iterator(); it.hasNext(); ) {
            System.out.println(it.next());
        }

    }

}
</code></pre><p>原理</p>
<pre><code>Iterator iterator(): 取出元素的方式：迭代器

该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。

所以该迭代器对象是在容器内部实现的。

对于使用容器者而言，具体的实现方式不重要，只要通过容器获取到实现的迭代器的对象即可，也就是iterator方法。

Iterator接口就是对所有的Collection容器进行元素取出的公共接口。
</code></pre><h4 id="5、List和Set的特点"><a href="#5、List和Set的特点" class="headerlink" title="5、List和Set的特点"></a>5、List和Set的特点</h4><pre><code>Collection

|--    List：有序（存入和取出的顺序一致），元素都有索引，元素可以重复。

|-- Set：元素不能重复。
</code></pre><p>List：特有的常见方法</p>
<p>1、添加</p>
<pre><code>void add(index,element)
void add(index,collection)
</code></pre><p>2、删除</p>
<pre><code>Object remove(index)
</code></pre><p>3、修改</p>
<pre><code>Object set(index,element)
</code></pre><p>4、获取</p>
<pre><code>Object get(index)
int indexOf(Object)
int lastIndexOf(object)
List subList(fromIndex,toIndex)
</code></pre><p>list集合是可以完成对元素的增删改查的。</p>
<p>方法演示</p>
<pre><code>public class listDemo2 {

    public static void main(String[] args) {
        List list = new ArrayList();
        show(list);
    }

    private static void show(List list) {
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);
        list.add(&quot;abc4&quot;);

        Iterator it = list.iterator();
        while(it.hasNext()) {
            System.out.println(&quot;next:&quot;+it.next());
        }

        //list特有的取出元素的方式，set只能通过迭代器方式取出元素
        for(int x=0; x&lt;list.size(); x++) {
            System.out.println(&quot;get:&quot;+list.get(x));
        }
    }

}
</code></pre><p>演示2</p>
<pre><code>public class listDemo3 {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);

        Iterator it = list.iterator();
        while(it.hasNext()) {
            Object obj = it.next();
            if(obj.equals(&quot;abc2&quot;)) {
                list.add(&quot;abc9&quot;);
            }else {                
                System.out.println(&quot;next:&quot;+obj);
            }            
        }

        System.out.println(it.next());
    }

}

执行时，抛出并发修改的异常。
Exception in thread &quot;main&quot;         
java.util.ConcurrentModificationException

原因：
Iterator it = list.iterator();迭代器检查list集合长度为3。
当list.add(&quot;abc9&quot;)，修改了集合长度时，迭代器不知道。

解决方案：使用Iterator接口的子接口listIterator来完成在迭代中对元素进修改。

public class listDemo3 {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;abc1&quot;);
        list.add(&quot;abc2&quot;);
        list.add(&quot;abc3&quot;);

        //获取列表迭代器对象，它可以实现在迭代过程中对元素的增删改查，注意只有list集合具备该迭代功能
        ListIterator it = list.listIterator();

        while(it.hasNext()) {
            Object obj = it.next();
            if(obj.equals(&quot;abc2&quot;)) {
                //it.add(&quot;abc9&quot;);
                it.set(&quot;abc9&quot;);
            }
        }

        System.out.println(list);

        while(it.hasPrevious()) {
            System.out.println(&quot;previous:&quot;+it.previous());
        }

    }

}
</code></pre><h4 id="6、List常用子类的特点"><a href="#6、List常用子类的特点" class="headerlink" title="6、List常用子类的特点"></a>6、List常用子类的特点</h4><p>List:</p>
<p>|– Vector：内部是数组数据结构，是同步的。增删，查询都很慢。</p>
<p>|– ArrayList：内部是数组数据结构，是不同步的。替代了Vector。查询的速度快。</p>
<p>|– LinkedList：内部是链表数据结构，是不同步的。增删元素的速度很快。</p>
<p>– addFirst()</p>
<p>– addLast()</p>
<p>– getFirst() 获取但不移除，如果链表为空，抛出NoSuchElement异常</p>
<p>– getLast()</p>
<p>– removeFirst() 获取并移除，如果链表为空，抛出NoSuchElement异常</p>
<p>– removeLast()</p>
<p>jdk1.6</p>
<p>– offerFirst()</p>
<p>– offerLast()</p>
<p>– peekFirst() 获取但不移除，如果链表为空，返回null</p>
<p>– peekLast()</p>
<p>– pollFirst() 获取并移除，如果链接为空，返回null</p>
<p>– pollLast()</p>
<pre><code>/**
 * 请使用LinkedList来模拟一个堆栈或者队列数据结构
 * 堆栈：先进后出
 * 队列：先进先出
 */
public class linkedListDemo {
    public static void main(String[] args) {

        DuiLie dl = new DuiLie();
        dl.myAdd(&quot;abc1&quot;);
        dl.myAdd(&quot;abc2&quot;);
        dl.myAdd(&quot;abc3&quot;);
        dl.myAdd(&quot;abc4&quot;);

        while(!dl.isNull()) {
            System.out.println(dl.myGet());
        }
    }
}

class DuiLie{
    private LinkedList link;

    public DuiLie() {
        link = new LinkedList();
    }

    public void myAdd(Object obj) {
        link.addLast(obj);
    }

    public Object myGet() {
        return link.removeFirst();
    }

    public boolean isNull() {
        return link.isEmpty();
    }
}
</code></pre><h4 id="7、ArrayList集合存储自定义对象"><a href="#7、ArrayList集合存储自定义对象" class="headerlink" title="7、ArrayList集合存储自定义对象"></a>7、ArrayList集合存储自定义对象</h4><pre><code>public class arrayListTest {

    public static void main(String[] args) {

        ArrayList al = new ArrayList();
        al.add(new Person(&quot;lisi1&quot;,21));
        al.add(new Person(&quot;lisi2&quot;,22));
        al.add(new Person(&quot;lisi3&quot;,23));
        al.add(new Person(&quot;lisi4&quot;,24));

        Iterator it = al.iterator();
        while(it.hasNext()) {
            //System.out.println(((Person) it.next()).getName());
            Person p = (Person) it.next();
            System.out.println(p.getName()+&quot;--&quot;+p.getAge());
        }

    }

}

class Person{
    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}    
</code></pre><h3 id="集合框架-HashSet集合"><a href="#集合框架-HashSet集合" class="headerlink" title="集合框架-HashSet集合"></a>集合框架-HashSet集合</h3><p>Set：元素不可以重复，是无序的。</p>
<p>Set接口中的方法和Collection一致。</p>
<p>|– HashSet：内部数据结构是Hash表，是不同步的。</p>
<p>|– TreeSet：</p>
<pre><code>public static void main(String[] args) {
        HashSet hs = new HashSet();

        hs.add(&quot;aaa&quot;);
        hs.add(&quot;bbb&quot;);
        hs.add(&quot;ccc&quot;);
        hs.add(&quot;ddd&quot;);

        Iterator it = hs.iterator();

        while(it.hasNext()) {
            System.out.println(it.next());
        }

    }
</code></pre><p>集合框架 - 哈希表</p>
<p>HashSet集合数据结构是哈希表，所以存储元素的时候，首先使用元素的hashCode方法来确定位置，如果位置相同，在通过元素的equals方法来确定内容是否相同。    </p>
<pre><code>class Person{

    ...

    public int hashCode() {
        //System.out.println(this);
        return name.hashCode()+age*27;
    }

    public boolean equals(Object obj) {
    if(this == obj)
            return true;

    if(!(obj instanceof Person))
        throw new ClassCastException(&quot;类型不对&quot;);

    Person p = (Person)obj;

    System.out.println(this.name+&quot;...&quot;+this.age+&quot;...equals...&quot;+p.name+&quot;...&quot;+p.age);

    return this.name.equals(p.name) &amp;&amp; this.age == p.age;
}

    ...

}    

public class hashSetDemo2 {

    public static void main(String[] args) {

        HashSet hs = new HashSet();

        hs.add(new Person(&quot;lisi1&quot;,21));
        hs.add(new Person(&quot;lisi2&quot;,22));
        hs.add(new Person(&quot;lisi3&quot;,23));
        hs.add(new Person(&quot;lisi4&quot;,24));
        hs.add(new Person(&quot;lisi4&quot;,24));

        Iterator it = hs.iterator();

        while(it.hasNext()) {
            Person p = (Person)it.next();
            System.out.println(p.getName()+&quot;...&quot;+p.getAge());
        }

    }

}
</code></pre><h4 id="8、删除ArrayList集合中的重复元素"><a href="#8、删除ArrayList集合中的重复元素" class="headerlink" title="8、删除ArrayList集合中的重复元素"></a>8、删除ArrayList集合中的重复元素</h4><pre><code>public class arrayListPractice {

    public static void main(String[] args) {
        ArrayList al = new ArrayList();
        al.add(&quot;abc1&quot;);
        al.add(&quot;abc2&quot;);
        al.add(&quot;abc3&quot;);
        al.add(&quot;abc4&quot;);
        al.add(&quot;abc1&quot;);
        al.add(&quot;abc3&quot;);

        System.out.println(al);

        al = getSingleElement(al);

        System.out.println(al);
    }

    private static ArrayList getSingleElement(ArrayList al) {
        //1、定义临时容器
        ArrayList temp = new ArrayList();
        //2、迭代al集合
        Iterator it = al.iterator();
        while(it.hasNext()) {
            Object obj = it.next();
            //3、判断是否重复
            if(!(temp.contains(obj))) {
                temp.add(obj);
            }
        }
        return temp;
    }

}

输出结果：
[abc1, abc2, abc3, abc4, abc1, abc3]
[abc1, abc2, abc3, abc4]

换成自定义对象测试：

    public static void main(String[] args) {
        ArrayList al = new ArrayList();
        al.add();
        al.add(&quot;abc2&quot;);
        al.add(&quot;abc3&quot;);
        al.add(&quot;abc4&quot;);
        al.add(&quot;abc1&quot;);
        al.add(&quot;abc3&quot;);

        System.out.println(al);

        al = getSingleElement(al);

        System.out.println(al);
    }

输出结果：
[lisi1:21, lisi2:22, lisi3:23, lisi4:24, lisi2:22, lisi3:23]
[lisi1:21, lisi2:22, lisi3:23, lisi4:24, lisi2:22, lisi3:23]

原因分析：
contains方法是用的equals方法来比较两个元素是否相同。
equals方法是自定义类继承的object中的方法，所以比较的是对象的内存地址。

所以，要到Person类中对equals方法进行重写覆盖，就像String类对equals方法进行了重写一样，只要内容相同，即视为元素相同。

public boolean equals(Object obj) {
    if(this == obj)
            return true;

    if(!(obj instanceof Person))
        throw new ClassCastException(&quot;类型不对&quot;);

    Person p = (Person)obj;

    //System.out.println(this.name+&quot;...&quot;+this.age+&quot;...equals...&quot;+p.name+&quot;...&quot;+p.age);

    return this.name.equals(p.name) &amp;&amp; this.age == p.age;
}
</code></pre><h4 id="9、集合框架-LinkedHashSet集合"><a href="#9、集合框架-LinkedHashSet集合" class="headerlink" title="9、集合框架-LinkedHashSet集合"></a>9、集合框架-LinkedHashSet集合</h4><p>HashSet保证了唯一，但是无序。</p>
<p>LinkedHashSet用链表进行了扩展。</p>
<pre><code>public static void main(String[] args) {
    HashSet hs = new LinkedHashSet();

    hs.add(&quot;abc2&quot;);
    hs.add(&quot;abc1&quot;);
    hs.add(&quot;abc3&quot;);
    hs.add(&quot;abc4&quot;);

    Iterator it = hs.iterator();
    while(it.hasNext()) {
        System.out.println(it.next());
    }
}

输出结果：
abc2
abc1
abc3
abc4

保证了集合既有序且唯一。
</code></pre><h4 id="10、集合框架-TreeSet集合"><a href="#10、集合框架-TreeSet集合" class="headerlink" title="10、集合框架 - TreeSet集合"></a>10、集合框架 - TreeSet集合</h4><p>TreeSet：可以对Set集合中的元素进行排序。是不同步的。</p>
<p>判断元素唯一性的方式：就是根据比较方法的返回结果是否为0，是0，就是相同元素，不存。</p>
<h5 id="TreeSet对元素进行排序的方式一："><a href="#TreeSet对元素进行排序的方式一：" class="headerlink" title="TreeSet对元素进行排序的方式一："></a>TreeSet对元素进行排序的方式一：</h5><p>让元素自身具备比较功能，元素就需要实现Comparable接口，重写覆盖compareTo方法。</p>
<pre><code>public static void main(String[] args) {
    TreeSet ts = new TreeSet();

    ts.add(&quot;abc&quot;);
    ts.add(&quot;aaa&quot;);
    ts.add(&quot;abbc&quot;);
    ts.add(&quot;acsw&quot;);

    Iterator it = ts.iterator();

    while(it.hasNext()) {
        System.out.println(it.next());
    }

}

输出结果：    
aaa
abbc
abc
acsw
</code></pre><p>String类已经实现了Comparable接口，重写了compareTo方法，所以添加时对元素进行了排序。自定义的类，需要按需求自定义排序方式。</p>
<pre><code>class Person implements Comparable{
    ...
    //按年龄排序，年龄相同的按姓名排序
    public int compareTo(Object o) {
        Person p = (Person)o;
        int temp = this.age - p.age;
        return temp == 0?this.name.compareTo(p.name):temp;
    }
    ...
}

public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet ts = new TreeSet();

        ts.add(new Person(&quot;zhangsan&quot;,28));
        ts.add(new Person(&quot;wangwu&quot;,21));
        ts.add(new Person(&quot;lisi&quot;,26));
        ts.add(new Person(&quot;zhaoliu&quot;,28));        

        Iterator it = ts.iterator();

        while(it.hasNext()) {
            System.out.println(it.next());
        }

    }
}

输出结果：
wangwu:21
lisi:26
zhangsan:28
zhaoliu:28
</code></pre><h5 id="TreeSet对元素进行排序的方式二："><a href="#TreeSet对元素进行排序的方式二：" class="headerlink" title="TreeSet对元素进行排序的方式二："></a>TreeSet对元素进行排序的方式二：</h5><p>让集合自身具备比较功能，自定义一个比较器类，实现Comparator接口，重写覆盖compare方法。将该类对象作为参数传递给TreeSet集合的构造函数。</p>
<pre><code>//创建比较器
public class ComparableDemo implements Comparator {

    public int compare(Object o1, Object o2) {
        Person p1 = (Person)o1;
        Person p2 = (Person)o2;
        //按名字排序，名字相同者按年龄排序
        int temp = p1.getName().compareTo(p2.getName());
        return temp==0?p1.getAge()-p2.getAge():temp;
    }

}

public class TreeSetDemo {

    public static void main(String[] args) {
        //创建集合时传入比较器
        TreeSet ts = new TreeSet(new ComparableDemo());

        ts.add(new Person(&quot;zhangsan&quot;,28));
        ts.add(new Person(&quot;wangwu&quot;,21));
        ts.add(new Person(&quot;lisi&quot;,26));
        ts.add(new Person(&quot;zhaoliu&quot;,28));        

        Iterator it = ts.iterator();

        while(it.hasNext()) {
            System.out.println(it.next());
        }

    }

}

输出结果：
lisi:26
wangwu:21
zhangsan:28
zhaoliu:28

集合比较器优先于元素比较器，且更为常用。
</code></pre><h4 id="TreeSet集合练习-字符串长度排序"><a href="#TreeSet集合练习-字符串长度排序" class="headerlink" title="TreeSet集合练习-字符串长度排序"></a>TreeSet集合练习-字符串长度排序</h4><pre><code>public class TreeSetPractice {

    public static void main(String[] args) {
        TreeSet ts = new TreeSet();

        ts.add(&quot;aaa&quot;);
        ts.add(&quot;zzzz&quot;);
        ts.add(&quot;bhjan&quot;);
        ts.add(&quot;lsdds&quot;);
        ts.add(&quot;hahaj&quot;);

        Iterator it = ts.iterator();

        while(it.hasNext()) {
            System.out.println(it.next());
        }
    }

}
输出结果：
aaa
bhjan
hahaj
lsdds
zzzz
</code></pre><p>String类元素默认的是自然排序，想要按字条串长度排序，只能通过修改集合<br>的比较器来实现。</p>
<pre><code>class ComparatorByLength implements Comparator{
    public int compare(Object o1, Object o2) {
        String s1 = (String)o1;
        String s2 = (String)o2;
        int temp = s1.length() - s2.length();
        return temp==0?s1.compareTo(s2):temp;
    }
}

public class TreeSetPractice {

    public static void main(String[] args) {
        TreeSet ts = new TreeSet(new ComparatorByLength());

        ...        
    }

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/27/java/java-collections/java-collection-framework/" data-id="cjgxcg483001nr9p3buzi3onj" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/collecionsFramework/">collecionsFramework</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/09/java/java-collections/java-collection-generic/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nieuwer</strong>
      <div class="article-nav-title">
        
          集合框架二 - 泛型
        
      </div>
    </a>
  
  
    <a href="/2017/12/23/java/java-api/basic-data-class/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">基本数据类型包装类</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/angularjs/">angularjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">bootstrap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collecionsFramework/">collecionsFramework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css-grid/">css-grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsp/">jsp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reflect/">reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/regex/">regex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session-cookie/">session cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/足球/">足球</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IO/" style="font-size: 20px;">IO</a> <a href="/tags/angular/" style="font-size: 17.14px;">angular</a> <a href="/tags/api/" style="font-size: 14.29px;">api</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/collecionsFramework/" style="font-size: 15.71px;">collecionsFramework</a> <a href="/tags/css-grid/" style="font-size: 10px;">css-grid</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/jsp/" style="font-size: 12.86px;">jsp</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/reflect/" style="font-size: 10px;">reflect</a> <a href="/tags/regex/" style="font-size: 10px;">regex</a> <a href="/tags/servlet/" style="font-size: 11.43px;">servlet</a> <a href="/tags/session-cookie/" style="font-size: 10px;">session cookie</a> <a href="/tags/spring/" style="font-size: 18.57px;">spring</a> <a href="/tags/thread/" style="font-size: 11.43px;">thread</a> <a href="/tags/足球/" style="font-size: 10px;">足球</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/08/java/spring/spring-10/">第十章 Spring事务管理</a>
          </li>
        
          <li>
            <a href="/2018/05/06/java/spring/spring-9/">第九章 spring与JDBC模板</a>
          </li>
        
          <li>
            <a href="/2018/05/06/java/spring/spring-8/">第八章 Spring与AOP AspectJ基于XML的AOP实现</a>
          </li>
        
          <li>
            <a href="/2018/05/06/java/spring/spring-7/">第七章 Spring与AOP AspectJ基于注解的AOP实现</a>
          </li>
        
          <li>
            <a href="/2018/05/05/java/spring/spring-6/">第六章 Spring与AOP AspectJ对AOP的实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>