<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>React/React Native的ES5 ES6写法对照表 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="React/React Native的ES5 ES6写法对照表">
<meta name="keywords" content="react, react native">
<meta property="og:type" content="article">
<meta property="og:title" content="React&#x2F;React Native的ES5 ES6写法对照表">
<meta property="og:url" content="http://yoursite.com/2017/08/17/react-native-es5-es6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="React/React Native的ES5 ES6写法对照表">
<meta property="og:updated_time" content="2017-08-17T07:09:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React&#x2F;React Native的ES5 ES6写法对照表">
<meta name="twitter:description" content="React/React Native的ES5 ES6写法对照表">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-react-native-es5-es6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/17/react-native-es5-es6/" class="article-date">
  <time datetime="2017-08-17T06:54:33.000Z" itemprop="datePublished">2017-08-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/react/">react</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      React/React Native的ES5 ES6写法对照表
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘抄：<a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8" target="_blank" rel="external">React/React Native 的ES5 ES6写法对照表</a></p>
<p>###一、模块</p>
<p>#####1、引用</p>
<p>在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样：</p>
<pre><code>//ES5
var React = require(&quot;react-native&quot;);
var {
    Image,
    Text,
    PropTypes
} = React;  //引用不同的React Native组件
</code></pre><p>在ES6里，import写法更为标准</p>
<pre><code>//ES6
import React, {
    Image, 
    Text,
    PropTypes
} from &apos;react-native&apos;;
</code></pre><p>#####2、导出单个类</p>
<p>在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出</p>
<pre><code>//ES5
var MyComponent = React.createClass({
    ...
});
module.exports = MyComponent;
</code></pre><p>在ES6里，通常用export default来实现相同的功能：</p>
<pre><code>//ES6
export default class MyComponent extends React.Component{
    ...
}
</code></pre><p>引用的时候也类似：</p>
<pre><code>//ES5
var MyComponent = require(&apos;./MyComponent.js&apos;);

//ES6
import MyComponent from &apos;./MyComponent.js&apos;;
</code></pre><p>###二、组件</p>
<p>#####1、定义组件</p>
<p>在ES5里，通常通过React.createClass来定义一个组件类，像这样：</p>
<pre><code>//ES5
var Photo = React.createClass({
    render: function() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    },
});
</code></pre><p>在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样：</p>
<pre><code>//ES6
class Photo extends React.Component {
    render() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    }
}    
</code></pre><p>#####2、给组件定义方法</p>
<p>从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。</p>
<p>//ES5</p>
<pre><code>var Photo = React.createClass({
    componentWillMount: function(){

    },
    render: function() {
        return (
            &lt;Image source={this.props.source} /&gt;
        );
    },
});
</code></pre><p>//ES6</p>
<p>class Photo extends React.Component {<br>    componentWillMount() {</p>
<pre><code>}
render() {
    return (
        &lt;Image source={this.props.source} /&gt;
    );
}
</code></pre><p>}</p>
<p>#####3、定义组件的属性类型和默认属性</p>
<p>在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现</p>
<pre><code>//ES5 
var Video = React.createClass({
    getDefaultProps: function() {
        return {
            autoPlay: false,
            maxLoops: 10,
        };
    },
    propTypes: {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    },
    render: function() {
        return (
            &lt;View /&gt;
        );
    },
});
</code></pre><p>在ES6里，可以统一使用static成员来实现</p>
<pre><code>//ES6
class Video extends React.Component {
    static defaultProps = {
        autoPlay: false,
        maxLoops: 10,
    };  // 注意这里有分号
    static propTypes = {
        autoPlay: React.PropTypes.bool.isRequired,
        maxLoops: React.PropTypes.number.isRequired,
        posterFrameSrc: React.PropTypes.string.isRequired,
        videoSrc: React.PropTypes.string.isRequired,
    };  // 注意这里有分号
    render() {
        return (
            &lt;View /&gt;
        );
    } // 注意这里既没有分号也没有逗号
}
</code></pre><p>也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思：</p>
<pre><code>//ES6
class Video extends React.Component {
    render() {
        return (
            &lt;View /&gt;
        );
    }
}
Video.defaultProps = {
    autoPlay: false,
    maxLoops: 10,
};
Video.propTypes = {
    autoPlay: React.PropTypes.bool.isRequired,
    maxLoops: React.PropTypes.number.isRequired,
    posterFrameSrc: React.PropTypes.string.isRequired,
    videoSrc: React.PropTypes.string.isRequired,
};
</code></pre><p>注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。</p>
<p>#####4、初始化state</p>
<p>ES5下情况类似，</p>
<pre><code>//ES5 
var Video = React.createClass({
    getInitialState: function() {
        return {
            loopsRemaining: this.props.maxLoops,
        };
    },
})
</code></pre><p>ES6下，有两种写法：</p>
<pre><code>//ES6
class Video extends React.Component {
    state = {
        loopsRemaining: this.props.maxLoops,
    }
}
</code></pre><p>不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：</p>
<pre><code>//ES6
class Video extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            loopsRemaining: this.props.maxLoops,
        };
    }
}
</code></pre><p>###三、把方法作为回调提供</p>
<p>#####1、写法</p>
<p>在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。</p>
<pre><code>//ES5
var PostInfo = React.createClass({
    handleOptionsButtonClick: function(e) {
        // Here, &apos;this&apos; refers to the component instance.
        this.setState({showOptionsModal: true});
    },
    render: function(){
        return (
            &lt;TouchableHighlight onPress={this.handleOptionsButtonClick}&gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;
            &lt;/TouchableHighlight&gt;
        )
    },
});
</code></pre><p>在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用。</p>
<pre><code>//ES6
class PostInfo extends React.Component
{
    handleOptionsButtonClick(e){
        this.setState({showOptionsModal: true});
    }
    render(){
        return (
            &lt;TouchableHighlight 
                onPress={this.handleOptionsButtonClick.bind(this)}
                onPress={e=&gt;this.handleOptionsButtonClick(e)}
                &gt;
                &lt;Text&gt;{this.props.label}&lt;/Text&gt;
            &lt;/TouchableHighlight&gt;
        )
    },
}
</code></pre><p>#####2、箭头函数</p>
<p>箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。</p>
<pre><code>// 箭头函数的例子
()=&gt;1
v=&gt;v+1
(a,b)=&gt;a+b
()=&gt;{
    alert(&quot;foo&quot;);
}
e=&gt;{
    if (e == 0){
        return 0;
    }
    return 1000/e;
}
</code></pre><p>需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
<p>//错误的做法</p>
<pre><code>class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused.bind(this));
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused.bind(this));
    }
    onAppPaused(event){
    }
}
</code></pre><p>//正确的做法</p>
<pre><code>class PauseMenu extends React.Component{
    constructor(props){
        super(props);
        this._onAppPaused = this.onAppPaused.bind(this);
    }
    componentWillMount(){
        AppStateIOS.addEventListener(&apos;change&apos;, this._onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&apos;change&apos;, this._onAppPaused);
    }
    onAppPaused(event){
    }
}
</code></pre><p>从这个帖子中我们还学习到一种新的做法：</p>
<p>// 正确的做法</p>
<pre><code>class PauseMenu extends React.Component{
    componentWillMount(){
        AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused);
    }
    componentDidUnmount(){
        AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused);
    }
    onAppPaused = (event) =&gt; {
        //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针
    }
}
</code></pre><p>###四、在es6中Mixins不再推荐使用</p>
<p>在ES5下，我们经常使用mixin来为我们的类添加一些新的方法，譬如PureRenderMixin</p>
<pre><code>var PureRenderMixin = require(&apos;react-addons-pure-render-mixin&apos;);
React.createClass({
  mixins: [PureRenderMixin],

  render: function() {
    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;
  }
});
</code></pre><p>然而现在官方已经不再打算在ES6里继续推行Mixin。</p>
<p>对于库编写者而言，应当尽快放弃Mixin的编写方式，推荐一种新的编码方式。</p>
<pre><code>//Enhance.js
import { Component } from &quot;React&quot;;

export var Enhance = ComposedComponent =&gt; class extends Component {
    constructor() {
        this.state = { data: null };
    }
    componentDidMount() {
        this.setState({ data: &apos;Hello&apos; });
    }
    render() {
        return &lt;ComposedComponent {...this.props} data={this.state.data} /&gt;;
    }
};

//HigherOrderComponent.js
import { Enhance } from &quot;./Enhance&quot;;

class MyComponent {
    render() {
        if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;;
        return &lt;div&gt;{this.data}&lt;/div&gt;;
    }
}

export default Enhance(MyComponent); // Enhanced component
</code></pre><p>用一个“增强函数”，来为某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。</p>
<p>###五、es6+带来的其它好处</p>
<p>解构&amp;属性延展</p>
<p>结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便。</p>
<p>这个例子把className以外的所有属性传递给了div标签：</p>
<pre><code>class AutoloadingPostsGrid extends React.Component {
    render() {
        var {
            className,
            ...others,  // contains all properties of this.props except for className
        } = this.props;
        return (
            &lt;div className={className}&gt;
                &lt;PostsGrid {...others} /&gt;
                &lt;button onClick={this.handleLoadMoreClick}&gt;Load more&lt;/button&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre><p>下面这种写法，则是传递所有属性的同时，用override来覆盖属性中的className值：</p>
<pre><code>&lt;div {...this.props} className=&quot;override&quot;&gt;
    …
&lt;/div&gt;
</code></pre><p>这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值</p>
<pre><code>&lt;div className=&quot;base&quot; {...this.props}&gt;
    …
&lt;/div&gt;    
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/17/react-native-es5-es6/" data-id="cjc7alxd0001ru0p3b9dljwkz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/14/angular-errors/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          angular应用中常见问题记录
        
      </div>
    </a>
  
  
    <a href="/2017/08/14/github-hexo-blog/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">github+hexo博客并备份</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/angularjs/">angularjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">bootstrap</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/github/">github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collecionsFramework/">collecionsFramework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css-grid/">css-grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/足球/">足球</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/angular/" style="font-size: 20px;">angular</a> <a href="/tags/api/" style="font-size: 15px;">api</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/collecionsFramework/" style="font-size: 17.5px;">collecionsFramework</a> <a href="/tags/css-grid/" style="font-size: 10px;">css-grid</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/thread/" style="font-size: 12.5px;">thread</a> <a href="/tags/足球/" style="font-size: 10px;">足球</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/09/java-collection-utilities/">集合框架五 - 工具类</a>
          </li>
        
          <li>
            <a href="/2018/01/09/java-collection-map/">集合框架四 - Map集合</a>
          </li>
        
          <li>
            <a href="/2018/01/09/java-collection-notes/">集合框架三 - 查阅技巧</a>
          </li>
        
          <li>
            <a href="/2018/01/09/java-collection-generic/">集合框架二 - 泛型</a>
          </li>
        
          <li>
            <a href="/2017/12/27/java-collection-framework/">集合框架一 - Collecion集合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>